# Vulnerability Scanning Documentation

## Overview

The SPARC platform implements comprehensive vulnerability scanning across all layers of the application stack. This includes dependency scanning, container image scanning, static code analysis, infrastructure as code scanning, and dynamic application security testing (DAST).

## Scanning Types

### 1. Dependency Vulnerability Scanning

Identifies vulnerabilities in third-party dependencies:

- **npm audit**: Native Node.js vulnerability scanning
- **Snyk**: Advanced vulnerability database with fix recommendations
- **OWASP Dependency Check**: CVE identification with CVSS scoring

### 2. Container Security Scanning

Scans Docker images for vulnerabilities:

- **Trivy**: Comprehensive vulnerability scanner for containers
- **Grype**: Anchore's vulnerability scanner with SBOM support
- **Docker Scout**: Native Docker vulnerability scanning (if enabled)

### 3. Static Application Security Testing (SAST)

Analyzes source code for security issues:

- **CodeQL**: GitHub's semantic code analysis
- **Semgrep**: Pattern-based static analysis with custom rules
- **GitLeaks**: Secret detection in code and git history
- **Bandit**: Python security linter (for any Python scripts)

### 4. Infrastructure as Code (IaC) Scanning

Validates infrastructure configurations:

- **Checkov**: Comprehensive IaC scanner
- **Terrascan**: Terraform-specific security scanning
- **Trivy**: Configuration file scanning

### 5. Dynamic Application Security Testing (DAST)

Tests running applications for vulnerabilities:

- **OWASP ZAP**: Full application security testing
- **Custom security tests**: Application-specific security validation

### 6. License Compliance Scanning

Ensures license compatibility:

- **License Finder**: Ruby gem for license detection
- **FOSSA**: Comprehensive license compliance (if configured)

## Automated Scanning

### Continuous Integration

Vulnerability scanning runs automatically on:

- Every push to `main` and `develop` branches
- All pull requests targeting `main`
- Daily scheduled scans at 2 AM UTC
- Manual workflow dispatch

### GitHub Actions Workflow

The security scanning workflow (`.github/workflows/security-scan.yml`) orchestrates all scanning activities:

```yaml
name: Security Vulnerability Scan
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * *'
```

## Scan Results

### Security Dashboard

Results are available in multiple locations:

1. **GitHub Security Tab**
   - Code scanning alerts
   - Dependabot alerts
   - Secret scanning alerts

2. **CI/CD Artifacts**
   - Detailed scan reports
   - SARIF files for tool integration
   - HTML summary reports

3. **Monitoring Systems**
   - Grafana dashboards for trends
   - Prometheus metrics for alerting
   - SIEM integration for security events

### Report Format

The consolidated security report includes:

- Executive summary with severity counts
- Detailed vulnerability listings
- Remediation recommendations
- Trend analysis
- Compliance status

## Vulnerability Management

### Severity Levels

Vulnerabilities are classified by severity:

- **Critical**: Immediate action required (CVSS 9.0-10.0)
- **High**: Address within 7 days (CVSS 7.0-8.9)
- **Medium**: Address within 30 days (CVSS 4.0-6.9)
- **Low**: Address in next release (CVSS 0.1-3.9)
- **Info**: Informational only

### Response Process

1. **Critical Vulnerabilities**
   ```
   1. Automated GitHub issue creation
   2. Slack notification to security team
   3. Emergency patch deployment
   4. Post-mortem analysis
   ```

2. **High Vulnerabilities**
   ```
   1. Development team notification
   2. Fix branch creation
   3. Expedited code review
   4. Patch release
   ```

3. **Medium/Low Vulnerabilities**
   ```
   1. Backlog item creation
   2. Regular sprint planning
   3. Batch updates
   ```

## Configuration

### Scanner Configuration Files

1. **npm audit**
   - `.npmrc` - Configuration options
   - `npm-shrinkwrap.json` - Lock file for consistency

2. **Snyk**
   - `.snyk` - Ignore rules and patches
   - Policy file for custom rules

3. **OWASP Dependency Check**
   - `.github/dependency-check-suppressions.xml` - False positive suppressions

4. **OWASP ZAP**
   - `.github/zap-rules.tsv` - Custom rule configuration

### Environment Variables

Required for full functionality:

```bash
# Snyk Integration
SNYK_TOKEN=your-snyk-token

# FOSSA Integration (optional)
FOSSA_API_KEY=your-fossa-key

# Slack Notifications
SLACK_WEBHOOK=https://hooks.slack.com/services/...

# GitHub Token (usually automatic)
GITHUB_TOKEN=***
```

## Custom Rules

### Semgrep Rules

Add custom security patterns in `.semgrep.yml`:

```yaml
rules:
  - id: custom-sql-injection
    pattern: |
      $QUERY = "SELECT * FROM users WHERE id = " + $INPUT
    message: Potential SQL injection vulnerability
    severity: ERROR
```

### CodeQL Queries

Custom CodeQL queries in `.github/codeql/custom-queries/`:

```ql
import javascript

from CallExpr call
where call.getCalleeName() = "eval"
select call, "Dangerous use of eval()"
```

## Suppressing False Positives

### Dependency Check Suppressions

Edit `.github/dependency-check-suppressions.xml`:

```xml
<suppress>
    <notes>False positive - only affects different version</notes>
    <cve>CVE-2021-12345</cve>
</suppress>
```

### Snyk Ignores

Create `.snyk` file:

```yaml
version: v1.0.0
ignore:
  SNYK-JS-LODASH-567746:
    - '*':
        reason: Not exploitable in our usage
        expires: '2024-12-31T23:59:59.999Z'
```

### Inline Code Suppressions

For static analysis tools:

```typescript
// nosemgrep: typescript.lang.security.audit.unsafe-eval
eval(userInput); // Required for dynamic code execution
```

## Integration with Development

### Pre-commit Hooks

Local scanning before commits:

```bash
npm install --save-dev husky
npx husky add .husky/pre-commit "npm audit --production"
```

### IDE Integration

1. **VS Code Extensions**
   - Snyk Vulnerability Scanner
   - GitLens (for git history)
   - SonarLint

2. **IntelliJ IDEA Plugins**
   - Snyk Vulnerability Scanner
   - Checkmarx

### Pull Request Checks

Security scanning is mandatory for PR approval:

- All scans must pass
- No new critical/high vulnerabilities
- Security review for sensitive changes

## Metrics and Reporting

### Key Metrics

1. **Mean Time to Remediation (MTTR)**
   - Critical: < 24 hours
   - High: < 7 days
   - Medium: < 30 days

2. **Vulnerability Density**
   - Vulnerabilities per 1000 lines of code
   - Target: < 0.5

3. **Dependency Freshness**
   - Percentage of dependencies up-to-date
   - Target: > 80%

### Monthly Security Report

Automated reports include:

- Vulnerability trends
- Remediation performance
- Compliance status
- Security incidents
- Recommendations

## Best Practices

1. **Shift Left Security**
   - Scan during development
   - Fix vulnerabilities early
   - Security training for developers

2. **Defense in Depth**
   - Multiple scanning tools
   - Different scanning techniques
   - Regular penetration testing

3. **Continuous Improvement**
   - Regular tool updates
   - Custom rule development
   - Process refinement

4. **Supply Chain Security**
   - Verify dependency sources
   - Use lock files
   - Regular dependency updates

## Troubleshooting

### Common Issues

1. **Scan Timeouts**
   ```bash
   # Increase timeout in workflow
   timeout-minutes: 60
   ```

2. **Memory Issues**
   ```bash
   # Increase runner memory
   runs-on: ubuntu-latest-8gb
   ```

3. **Network Issues**
   ```bash
   # Retry configuration
   retry_attempts: 3
   retry_delay: 10
   ```

### Debug Mode

Enable verbose logging:

```yaml
env:
  ACTIONS_STEP_DEBUG: true
  ACTIONS_RUNNER_DEBUG: true
```

## Compliance

### Standards Supported

- OWASP Top 10
- CWE Top 25
- PCI DSS
- HIPAA
- SOC 2
- ISO 27001

### Audit Trail

All scan results are retained for:
- 90 days in GitHub Actions
- 1 year in archive storage
- Indefinitely in SIEM for critical findings

## Future Enhancements

1. **AI-Powered Analysis**
   - ML-based false positive reduction
   - Predictive vulnerability assessment
   - Automated fix generation

2. **Enhanced Integration**
   - Real-time IDE scanning
   - ChatOps integration
   - Automated patching

3. **Advanced Testing**
   - Fuzzing integration
   - Chaos engineering
   - Red team automation