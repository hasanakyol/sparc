import { Hono } from 'hono';
import { z } from 'zod';
import { HTTPException } from 'hono/http-exception';
import { eq, and, desc, gte } from 'drizzle-orm';
import { db, schema } from '../db';
import { 
  createMaintenanceScheduleSchema,
  updateMaintenanceScheduleSchema,
  CreateMaintenanceScheduleInput,
  UpdateMaintenanceScheduleInput
} from '../types';
import { logger } from '@sparc/shared';
import { trace } from '@opentelemetry/api';
import Redis from 'ioredis';

const tracer = trace.getTracer('maintenance-service');
const app = new Hono<{ Variables: { tenantId: string; userId: string; redis: Redis } }>();

// List preventive maintenance schedules
app.get('/schedules', async (c) => {
  const span = tracer.startSpan('listPreventiveMaintenanceSchedules');
  
  try {
    const tenantId = c.get('tenantId');
    const active = c.req.query('active');
    
    const conditions = [eq(schema.preventiveMaintenanceSchedules.tenantId, tenantId)];
    
    if (active !== undefined) {
      conditions.push(eq(schema.preventiveMaintenanceSchedules.active, active === 'true' ? 1 : 0));
    }
    
    const schedules = await db.select({
      schedule: schema.preventiveMaintenanceSchedules,
      createdByUser: {
        id: schema.users.id,
        username: schema.users.username,
        email: schema.users.email
      }
    })
    .from(schema.preventiveMaintenanceSchedules)
    .leftJoin(schema.users, eq(schema.preventiveMaintenanceSchedules.createdBy, schema.users.id))
    .where(and(...conditions))
    .orderBy(desc(schema.preventiveMaintenanceSchedules.createdAt));
    
    span.setAttributes({ 'schedules.count': schedules.length });
    
    return c.json({
      schedules: schedules.map(row => ({
        ...row.schedule,
        createdByUser: row.createdByUser?.id ? row.createdByUser : null
      }))
    });
  } catch (error) {
    span.recordException(error as Error);
    logger.error('Failed to list preventive maintenance schedules', { error });
    throw new HTTPException(500, { message: 'Failed to list schedules' });
  } finally {
    span.end();
  }
});

// Get single schedule
app.get('/schedules/:id', async (c) => {
  const span = tracer.startSpan('getPreventiveMaintenanceSchedule');
  
  try {
    const tenantId = c.get('tenantId');
    const scheduleId = c.req.param('id');
    
    span.setAttributes({ 'schedule.id': scheduleId });
    
    const [schedule] = await db.select()
      .from(schema.preventiveMaintenanceSchedules)
      .where(and(
        eq(schema.preventiveMaintenanceSchedules.id, scheduleId),
        eq(schema.preventiveMaintenanceSchedules.tenantId, tenantId)
      ))
      .limit(1);
    
    if (!schedule) {
      throw new HTTPException(404, { message: 'Schedule not found' });
    }
    
    // Get recent work orders generated by this schedule
    const recentWorkOrders = await db.select()
      .from(schema.workOrders)
      .where(and(
        eq(schema.workOrders.tenantId, tenantId),
        eq(schema.workOrders.workOrderType, 'preventive'),
        gte(schema.workOrders.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)) // Last 30 days
      ))
      .orderBy(desc(schema.workOrders.createdAt))
      .limit(10);
    
    return c.json({
      schedule,
      recentWorkOrders: recentWorkOrders.filter(wo => 
        wo.title === (schedule.workOrderTemplate as any).title
      )
    });
  } catch (error) {
    span.recordException(error as Error);
    logger.error('Failed to get preventive maintenance schedule', { error });
    
    if (error instanceof HTTPException) throw error;
    throw new HTTPException(500, { message: 'Failed to get schedule' });
  } finally {
    span.end();
  }
});

// Create preventive maintenance schedule
app.post('/schedules', async (c) => {
  const span = tracer.startSpan('createPreventiveMaintenanceSchedule');
  
  try {
    const tenantId = c.get('tenantId');
    const userId = c.get('userId');
    const body = await c.req.json();
    
    // Validate input
    const input = createMaintenanceScheduleSchema.parse(body) as CreateMaintenanceScheduleInput;
    
    span.setAttributes({
      'schedule.name': input.name,
      'schedule.interval': input.interval,
      'schedule.deviceType': input.deviceType
    });
    
    // Calculate next generation date
    const nextGeneration = calculateNextGeneration(input.interval, input.intervalValue);
    
    // Create schedule
    const [schedule] = await db.insert(schema.preventiveMaintenanceSchedules)
      .values({
        tenantId,
        name: input.name,
        deviceType: input.deviceType,
        deviceIds: input.deviceIds || [],
        interval: input.interval,
        intervalValue: input.intervalValue,
        workOrderTemplate: input.workOrderTemplate,
        active: input.active ? 1 : 0,
        nextGeneration,
        createdBy: userId
      })
      .returning();
    
    logger.info('Preventive maintenance schedule created', { 
      scheduleId: schedule.id, 
      name: schedule.name 
    });
    
    return c.json({ schedule }, 201);
  } catch (error) {
    span.recordException(error as Error);
    logger.error('Failed to create preventive maintenance schedule', { error });
    
    if (error instanceof z.ZodError) {
      throw new HTTPException(400, { message: 'Invalid schedule data', cause: error.errors });
    }
    
    throw new HTTPException(500, { message: 'Failed to create schedule' });
  } finally {
    span.end();
  }
});

// Update preventive maintenance schedule
app.put('/schedules/:id', async (c) => {
  const span = tracer.startSpan('updatePreventiveMaintenanceSchedule');
  
  try {
    const tenantId = c.get('tenantId');
    const scheduleId = c.req.param('id');
    const body = await c.req.json();
    
    // Validate input
    const input = updateMaintenanceScheduleSchema.parse(body) as UpdateMaintenanceScheduleInput;
    
    span.setAttributes({ 'schedule.id': scheduleId });
    
    // Get existing schedule
    const [existing] = await db.select()
      .from(schema.preventiveMaintenanceSchedules)
      .where(and(
        eq(schema.preventiveMaintenanceSchedules.id, scheduleId),
        eq(schema.preventiveMaintenanceSchedules.tenantId, tenantId)
      ))
      .limit(1);
    
    if (!existing) {
      throw new HTTPException(404, { message: 'Schedule not found' });
    }
    
    // Build update data
    const updateData: any = {
      updatedAt: new Date()
    };
    
    if (input.name !== undefined) updateData.name = input.name;
    if (input.active !== undefined) updateData.active = input.active ? 1 : 0;
    if (input.interval !== undefined) updateData.interval = input.interval;
    if (input.intervalValue !== undefined) updateData.intervalValue = input.intervalValue;
    if (input.workOrderTemplate !== undefined) updateData.workOrderTemplate = input.workOrderTemplate;
    
    // Recalculate next generation if interval changed
    if (input.interval !== undefined || input.intervalValue !== undefined) {
      updateData.nextGeneration = calculateNextGeneration(
        input.interval || existing.interval,
        input.intervalValue || existing.intervalValue
      );
    }
    
    // Update schedule
    const [updated] = await db.update(schema.preventiveMaintenanceSchedules)
      .set(updateData)
      .where(and(
        eq(schema.preventiveMaintenanceSchedules.id, scheduleId),
        eq(schema.preventiveMaintenanceSchedules.tenantId, tenantId)
      ))
      .returning();
    
    logger.info('Preventive maintenance schedule updated', { scheduleId });
    
    return c.json({ schedule: updated });
  } catch (error) {
    span.recordException(error as Error);
    logger.error('Failed to update preventive maintenance schedule', { error });
    
    if (error instanceof z.ZodError) {
      throw new HTTPException(400, { message: 'Invalid update data', cause: error.errors });
    }
    
    if (error instanceof HTTPException) throw error;
    throw new HTTPException(500, { message: 'Failed to update schedule' });
  } finally {
    span.end();
  }
});

// Delete preventive maintenance schedule
app.delete('/schedules/:id', async (c) => {
  const span = tracer.startSpan('deletePreventiveMaintenanceSchedule');
  
  try {
    const tenantId = c.get('tenantId');
    const scheduleId = c.req.param('id');
    
    span.setAttributes({ 'schedule.id': scheduleId });
    
    // Delete schedule
    const result = await db.delete(schema.preventiveMaintenanceSchedules)
      .where(and(
        eq(schema.preventiveMaintenanceSchedules.id, scheduleId),
        eq(schema.preventiveMaintenanceSchedules.tenantId, tenantId)
      ));
    
    if (result.rowCount === 0) {
      throw new HTTPException(404, { message: 'Schedule not found' });
    }
    
    logger.info('Preventive maintenance schedule deleted', { scheduleId });
    
    return c.json({ success: true });
  } catch (error) {
    span.recordException(error as Error);
    logger.error('Failed to delete preventive maintenance schedule', { error });
    
    if (error instanceof HTTPException) throw error;
    throw new HTTPException(500, { message: 'Failed to delete schedule' });
  } finally {
    span.end();
  }
});

// Generate preventive maintenance work orders
app.post('/generate', async (c) => {
  const span = tracer.startSpan('generatePreventiveMaintenanceWorkOrders');
  
  try {
    const tenantId = c.get('tenantId');
    const userId = c.get('userId');
    const redis = c.get('redis');
    const body = await c.req.json();
    
    const { scheduleId, force } = z.object({
      scheduleId: z.string().uuid().optional(),
      force: z.boolean().optional()
    }).parse(body);
    
    span.setAttributes({ 
      'generate.scheduleId': scheduleId || 'all',
      'generate.force': force || false
    });
    
    // Get active schedules
    const conditions = [
      eq(schema.preventiveMaintenanceSchedules.tenantId, tenantId),
      eq(schema.preventiveMaintenanceSchedules.active, 1)
    ];
    
    if (scheduleId) {
      conditions.push(eq(schema.preventiveMaintenanceSchedules.id, scheduleId));
    }
    
    if (!force) {
      conditions.push(gte(schema.preventiveMaintenanceSchedules.nextGeneration, new Date()));
    }
    
    const schedules = await db.select()
      .from(schema.preventiveMaintenanceSchedules)
      .where(and(...conditions));
    
    if (schedules.length === 0) {
      return c.json({ 
        generated: 0, 
        message: 'No schedules due for generation' 
      });
    }
    
    let generatedCount = 0;
    const generatedWorkOrders = [];
    
    for (const schedule of schedules) {
      // Get applicable devices
      let deviceQuery = db.select()
        .from(schema.devices)
        .where(and(
          eq(schema.devices.tenantId, tenantId),
          eq(schema.devices.type, schedule.deviceType)
        ));
      
      // Filter by specific device IDs if specified
      if (schedule.deviceIds && (schedule.deviceIds as string[]).length > 0) {
        deviceQuery = deviceQuery.where(
          inArray(schema.devices.id, schedule.deviceIds as string[])
        );
      }
      
      const devices = await deviceQuery;
      
      // Generate work order for each device
      for (const device of devices) {
        // Check if there's already an open preventive maintenance work order
        const [existing] = await db.select()
          .from(schema.workOrders)
          .where(and(
            eq(schema.workOrders.tenantId, tenantId),
            eq(schema.workOrders.deviceId, device.id),
            eq(schema.workOrders.workOrderType, 'preventive'),
            inArray(schema.workOrders.status, ['open', 'assigned', 'in_progress'])
          ))
          .limit(1);
        
        if (!existing) {
          const template = schedule.workOrderTemplate as any;
          
          // Calculate scheduled date based on interval
          const scheduledDate = new Date();
          scheduledDate.setDate(scheduledDate.getDate() + 7); // Default to 7 days from now
          
          // Create work order
          const [workOrder] = await db.insert(schema.workOrders)
            .values({
              tenantId,
              deviceId: device.id,
              deviceType: device.type,
              workOrderType: 'preventive',
              priority: template.priority || 'medium',
              title: template.title,
              description: template.description,
              scheduledDate,
              estimatedCost: (template.estimatedHours * 75).toString(), // Default hourly rate
              createdBy: userId,
              status: 'open'
            })
            .returning();
          
          generatedWorkOrders.push(workOrder);
          generatedCount++;
          
          // Create history entry
          await db.insert(schema.maintenanceHistory)
            .values({
              tenantId,
              deviceId: device.id,
              workOrderId: workOrder.id,
              activityType: 'maintenance',
              description: `Preventive maintenance work order generated from schedule: ${schedule.name}`,
              performedBy: userId
            });
        }
      }
      
      // Update schedule's last generated and next generation dates
      await db.update(schema.preventiveMaintenanceSchedules)
        .set({
          lastGenerated: new Date(),
          nextGeneration: calculateNextGeneration(schedule.interval, schedule.intervalValue),
          updatedAt: new Date()
        })
        .where(eq(schema.preventiveMaintenanceSchedules.id, schedule.id));
    }
    
    // Update metrics
    if (generatedCount > 0) {
      await redis.incr('metrics:pm:generated', generatedCount);
      
      // Publish event for each generated work order
      for (const workOrder of generatedWorkOrders) {
        await redis.publish('maintenance:work-order:update', JSON.stringify({
          action: 'created',
          tenantId,
          workOrder
        }));
      }
    }
    
    logger.info('Preventive maintenance work orders generated', { 
      count: generatedCount,
      scheduleIds: schedules.map(s => s.id)
    });
    
    return c.json({
      generated: generatedCount,
      workOrders: generatedWorkOrders,
      message: `Generated ${generatedCount} preventive maintenance work orders`
    });
  } catch (error) {
    span.recordException(error as Error);
    logger.error('Failed to generate preventive maintenance work orders', { error });
    
    if (error instanceof z.ZodError) {
      throw new HTTPException(400, { message: 'Invalid request data', cause: error.errors });
    }
    
    throw new HTTPException(500, { message: 'Failed to generate work orders' });
  } finally {
    span.end();
  }
});

// Get preventive maintenance statistics
app.get('/stats', async (c) => {
  const span = tracer.startSpan('getPreventiveMaintenanceStats');
  
  try {
    const tenantId = c.get('tenantId');
    const startDate = c.req.query('startDate');
    const endDate = c.req.query('endDate');
    
    const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const end = endDate ? new Date(endDate) : new Date();
    
    // Get preventive maintenance work orders in date range
    const workOrders = await db.select()
      .from(schema.workOrders)
      .where(and(
        eq(schema.workOrders.tenantId, tenantId),
        eq(schema.workOrders.workOrderType, 'preventive'),
        gte(schema.workOrders.createdAt, start),
        lte(schema.workOrders.createdAt, end)
      ));
    
    // Calculate statistics
    const stats = {
      totalGenerated: workOrders.length,
      byStatus: workOrders.reduce((acc, wo) => {
        acc[wo.status] = (acc[wo.status] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      completionRate: workOrders.length > 0 
        ? (workOrders.filter(wo => wo.status === 'completed').length / workOrders.length) * 100
        : 0,
      averageCompletionTime: 0,
      totalLaborHours: 0,
      totalCost: 0,
      activeSchedules: 0
    };
    
    // Calculate average completion time and total labor hours
    const completedWorkOrders = workOrders.filter(wo => 
      wo.status === 'completed' && wo.completedDate
    );
    
    if (completedWorkOrders.length > 0) {
      const completionTimes = completedWorkOrders.map(wo => 
        (wo.completedDate!.getTime() - wo.createdAt.getTime()) / (1000 * 60 * 60) // Hours
      );
      stats.averageCompletionTime = completionTimes.reduce((sum, time) => sum + time, 0) / completionTimes.length;
      
      stats.totalLaborHours = completedWorkOrders.reduce((sum, wo) => 
        sum + (wo.laborHours ? parseFloat(wo.laborHours) : 0), 0
      );
      
      stats.totalCost = completedWorkOrders.reduce((sum, wo) => 
        sum + (wo.actualCost ? parseFloat(wo.actualCost) : 0), 0
      );
    }
    
    // Get active schedules count
    const [{ count }] = await db.select({ count: sql`count(*)` })
      .from(schema.preventiveMaintenanceSchedules)
      .where(and(
        eq(schema.preventiveMaintenanceSchedules.tenantId, tenantId),
        eq(schema.preventiveMaintenanceSchedules.active, 1)
      ));
    
    stats.activeSchedules = Number(count);
    
    span.setAttributes({
      'stats.totalGenerated': stats.totalGenerated,
      'stats.completionRate': stats.completionRate
    });
    
    return c.json({ stats });
  } catch (error) {
    span.recordException(error as Error);
    logger.error('Failed to get preventive maintenance statistics', { error });
    throw new HTTPException(500, { message: 'Failed to get statistics' });
  } finally {
    span.end();
  }
});

// Helper function to calculate next generation date
function calculateNextGeneration(interval: string, intervalValue: number): Date {
  const now = new Date();
  
  switch (interval) {
    case 'daily':
      return new Date(now.getTime() + intervalValue * 24 * 60 * 60 * 1000);
    case 'weekly':
      return new Date(now.getTime() + intervalValue * 7 * 24 * 60 * 60 * 1000);
    case 'monthly':
      const nextMonth = new Date(now);
      nextMonth.setMonth(nextMonth.getMonth() + intervalValue);
      return nextMonth;
    case 'quarterly':
      const nextQuarter = new Date(now);
      nextQuarter.setMonth(nextQuarter.getMonth() + intervalValue * 3);
      return nextQuarter;
    case 'annually':
      const nextYear = new Date(now);
      nextYear.setFullYear(nextYear.getFullYear() + intervalValue);
      return nextYear;
    default:
      return new Date(now.getTime() + 24 * 60 * 60 * 1000); // Default to 1 day
  }
}

export default app;