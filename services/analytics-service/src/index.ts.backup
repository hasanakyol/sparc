import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { prettyJSON } from 'hono/pretty-json';
import { HTTPException } from 'hono/http-exception';
import { Client } from '@opensearch-project/opensearch';
import Redis from 'ioredis';
import { PrismaClient } from '@sparc/shared/prisma';
import { z } from 'zod';
import { createLogger, format, transports } from 'winston';
import { WebSocketServer } from 'ws';
import { createServer } from 'http';

// Types and schemas
const AnalyticsQuerySchema = z.object({
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  tenantId: z.string().uuid(),
  siteId: z.string().uuid().optional(),
  buildingId: z.string().uuid().optional(),
  floorId: z.string().uuid().optional(),
  eventTypes: z.array(z.string()).optional(),
  limit: z.number().min(1).max(1000).default(100),
  offset: z.number().min(0).default(0)
});

const AnomalyDetectionSchema = z.object({
  tenantId: z.string().uuid(),
  entityType: z.enum(['user', 'door', 'camera', 'zone']),
  entityId: z.string().uuid(),
  threshold: z.number().min(0).max(1).default(0.8),
  timeWindow: z.number().min(1).max(168).default(24) // hours
});

const OccupancyQuerySchema = z.object({
  tenantId: z.string().uuid(),
  buildingId: z.string().uuid().optional(),
  floorId: z.string().uuid().optional(),
  zoneId: z.string().uuid().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  granularity: z.enum(['minute', 'hour', 'day']).default('hour')
});

// Advanced Video Analytics Schemas
const VideoAnalyticsConfigSchema = z.object({
  cameraId: z.string().uuid(),
  faceRecognition: z.object({
    enabled: z.boolean().default(false),
    confidence: z.number().min(0).max(1).default(0.8),
    enrollmentMode: z.boolean().default(false),
    watchlistEnabled: z.boolean().default(false)
  }).default({}),
  licensePlateRecognition: z.object({
    enabled: z.boolean().default(false),
    confidence: z.number().min(0).max(1).default(0.85),
    regions: z.array(z.string()).default(['US', 'EU']),
    watchlistEnabled: z.boolean().default(false)
  }).default({}),
  behaviorAnalysis: z.object({
    loiteringDetection: z.boolean().default(false),
    loiteringThreshold: z.number().min(30).max(3600).default(300), // seconds
    crowdAnalysis: z.boolean().default(false),
    crowdThreshold: z.number().min(5).max(100).default(10),
    directionAnalysis: z.boolean().default(false),
    speedAnalysis: z.boolean().default(false)
  }).default({}),
  zones: z.array(z.object({
    id: z.string().uuid(),
    name: z.string(),
    coordinates: z.array(z.object({
      x: z.number().min(0).max(1),
      y: z.number().min(0).max(1)
    })),
    type: z.enum(['detection', 'exclusion', 'counting']),
    analytics: z.array(z.string()).default([])
  })).default([])
});

const FaceRecognitionEventSchema = z.object({
  cameraId: z.string().uuid(),
  timestamp: z.string().datetime(),
  personId: z.string().uuid().optional(),
  confidence: z.number().min(0).max(1),
  boundingBox: z.object({
    x: z.number(),
    y: z.number(),
    width: z.number(),
    height: z.number()
  }),
  features: z.array(z.number()).optional(),
  isWatchlisted: z.boolean().default(false),
  metadata: z.record(z.any()).optional()
});

const LicensePlateEventSchema = z.object({
  cameraId: z.string().uuid(),
  timestamp: z.string().datetime(),
  plateNumber: z.string(),
  confidence: z.number().min(0).max(1),
  region: z.string(),
  boundingBox: z.object({
    x: z.number(),
    y: z.number(),
    width: z.number(),
    height: z.number()
  }),
  vehicleType: z.string().optional(),
  isWatchlisted: z.boolean().default(false),
  metadata: z.record(z.any()).optional()
});

const BehaviorEventSchema = z.object({
  cameraId: z.string().uuid(),
  timestamp: z.string().datetime(),
  eventType: z.enum(['loitering', 'crowd_formation', 'unusual_direction', 'speed_violation', 'object_left', 'object_removed']),
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  confidence: z.number().min(0).max(1),
  location: z.object({
    x: z.number(),
    y: z.number()
  }),
  duration: z.number().optional(),
  objectCount: z.number().optional(),
  metadata: z.record(z.any()).optional()
});

interface AccessPattern {
  userId: string;
  doorId: string;
  timestamp: Date;
  granted: boolean;
  location: {
    building: string;
    floor: string;
    zone: string;
  };
}

interface AnomalyScore {
  entityId: string;
  entityType: string;
  score: number;
  factors: string[];
  timestamp: Date;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

interface OccupancyData {
  location: {
    buildingId: string;
    floorId?: string;
    zoneId?: string;
  };
  timestamp: Date;
  count: number;
  capacity: number;
  utilizationRate: number;
}

interface PredictiveAlert {
  id: string;
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  entityId: string;
  entityType: string;
  probability: number;
  factors: string[];
  recommendedActions: string[];
  timestamp: Date;
}

// Advanced Video Analytics Interfaces
interface FaceRecognitionEvent {
  id: string;
  cameraId: string;
  tenantId: string;
  timestamp: Date;
  personId?: string;
  confidence: number;
  boundingBox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  features?: number[];
  isWatchlisted: boolean;
  metadata?: Record<string, any>;
}

interface LicensePlateEvent {
  id: string;
  cameraId: string;
  tenantId: string;
  timestamp: Date;
  plateNumber: string;
  confidence: number;
  region: string;
  boundingBox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  vehicleType?: string;
  isWatchlisted: boolean;
  metadata?: Record<string, any>;
}

interface BehaviorEvent {
  id: string;
  cameraId: string;
  tenantId: string;
  timestamp: Date;
  eventType: 'loitering' | 'crowd_formation' | 'unusual_direction' | 'speed_violation' | 'object_left' | 'object_removed';
  severity: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  location: {
    x: number;
    y: number;
  };
  duration?: number;
  objectCount?: number;
  metadata?: Record<string, any>;
}

interface VideoAnalyticsConfig {
  cameraId: string;
  faceRecognition: {
    enabled: boolean;
    confidence: number;
    enrollmentMode: boolean;
    watchlistEnabled: boolean;
  };
  licensePlateRecognition: {
    enabled: boolean;
    confidence: number;
    regions: string[];
    watchlistEnabled: boolean;
  };
  behaviorAnalysis: {
    loiteringDetection: boolean;
    loiteringThreshold: number;
    crowdAnalysis: boolean;
    crowdThreshold: number;
    directionAnalysis: boolean;
    speedAnalysis: boolean;
  };
  zones: Array<{
    id: string;
    name: string;
    coordinates: Array<{ x: number; y: number }>;
    type: 'detection' | 'exclusion' | 'counting';
    analytics: string[];
  }>;
}

interface MLModelConfig {
  modelId: string;
  modelType: 'face_recognition' | 'license_plate' | 'behavior_analysis' | 'object_detection';
  version: string;
  endpoint: string;
  apiKey?: string;
  confidence: number;
  enabled: boolean;
}

interface CrowdAnalysis {
  cameraId: string;
  timestamp: Date;
  totalCount: number;
  density: number;
  averageSpeed: number;
  flowDirection: {
    angle: number;
    magnitude: number;
  };
  hotspots: Array<{
    x: number;
    y: number;
    intensity: number;
  }>;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
}

interface IncidentPrediction {
  id: string;
  type: 'security_breach' | 'crowd_incident' | 'equipment_failure' | 'safety_violation';
  probability: number;
  timeToIncident: number; // minutes
  location: {
    buildingId: string;
    floorId?: string;
    zoneId?: string;
    cameraId?: string;
  };
  factors: string[];
  recommendedActions: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
}

// Initialize services
const app = new Hono();
const prisma = new PrismaClient();
const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

const opensearch = new Client({
  node: process.env.OPENSEARCH_URL || 'https://localhost:9200',
  auth: {
    username: process.env.OPENSEARCH_USERNAME || 'admin',
    password: process.env.OPENSEARCH_PASSWORD || 'admin'
  },
  ssl: {
    rejectUnauthorized: false
  }
});

const analyticsLogger = createLogger({
  level: 'info',
  format: format.combine(
    format.timestamp(),
    format.errors({ stack: true }),
    format.json()
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'analytics-error.log', level: 'error' }),
    new transports.File({ filename: 'analytics-combined.log' })
  ]
});

// Machine Learning and Analytics Engine
class AnalyticsEngine {
  private anomalyModels: Map<string, any> = new Map();
  private behaviorProfiles: Map<string, any> = new Map();
  private mlModels: Map<string, MLModelConfig> = new Map();
  private videoAnalyticsConfigs: Map<string, VideoAnalyticsConfig> = new Map();
  private faceDatabase: Map<string, { personId: string; features: number[]; metadata: any }> = new Map();
  private licensePlateWatchlist: Set<string> = new Set();
  private faceWatchlist: Set<string> = new Set();

  async detectAnomalies(tenantId: string, entityType: string, entityId: string, threshold: number = 0.8): Promise<AnomalyScore> {
    try {
      // Get historical data for the entity
      const historicalData = await this.getHistoricalData(tenantId, entityType, entityId);
      
      // Calculate baseline behavior patterns
      const baseline = await this.calculateBaseline(historicalData);
      
      // Get recent activity
      const recentActivity = await this.getRecentActivity(tenantId, entityType, entityId);
      
      // Calculate anomaly score using statistical analysis
      const score = await this.calculateAnomalyScore(baseline, recentActivity);
      
      // Determine severity based on score and threshold
      const severity = this.determineSeverity(score, threshold);
      
      // Identify contributing factors
      const factors = await this.identifyAnomalyFactors(baseline, recentActivity);

      const anomaly: AnomalyScore = {
        entityId,
        entityType,
        score,
        factors,
        timestamp: new Date(),
        severity
      };

      // Store anomaly in OpenSearch for further analysis
      await this.storeAnomaly(tenantId, anomaly);

      return anomaly;
    } catch (error) {
      analyticsLogger.error('Anomaly detection failed', { error, tenantId, entityType, entityId });
      throw error;
    }
  }

  async trackOccupancy(tenantId: string, buildingId?: string, floorId?: string, zoneId?: string): Promise<OccupancyData[]> {
    try {
      const query = {
        index: `access-events-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { term: { granted: true } },
                { range: { timestamp: { gte: 'now-24h' } } }
              ],
              ...(buildingId && { filter: [{ term: { buildingId } }] }),
              ...(floorId && { filter: [{ term: { floorId } }] }),
              ...(zoneId && { filter: [{ term: { zoneId } }] })
            }
          },
          aggs: {
            occupancy_over_time: {
              date_histogram: {
                field: 'timestamp',
                interval: '1h'
              },
              aggs: {
                entries: {
                  filter: { term: { eventType: 'entry' } }
                },
                exits: {
                  filter: { term: { eventType: 'exit' } }
                },
                net_occupancy: {
                  bucket_script: {
                    buckets_path: {
                      entries: 'entries>_count',
                      exits: 'exits>_count'
                    },
                    script: 'params.entries - params.exits'
                  }
                }
              }
            }
          }
        }
      };

      const response = await opensearch.search(query);
      
      // Process aggregation results into occupancy data
      const occupancyData = await this.processOccupancyResults(response.body.aggregations, tenantId, buildingId, floorId, zoneId);
      
      return occupancyData;
    } catch (error) {
      analyticsLogger.error('Occupancy tracking failed', { error, tenantId, buildingId, floorId, zoneId });
      throw error;
    }
  }

  async generatePredictiveAlerts(tenantId: string): Promise<PredictiveAlert[]> {
    try {
      const alerts: PredictiveAlert[] = [];

      // Analyze access patterns for potential security risks
      const accessAnomalies = await this.analyzeAccessPatterns(tenantId);
      alerts.push(...accessAnomalies);

      // Analyze occupancy trends for capacity planning
      const occupancyAlerts = await this.analyzeOccupancyTrends(tenantId);
      alerts.push(...occupancyAlerts);

      // Analyze device health for maintenance predictions
      const deviceAlerts = await this.analyzeDeviceHealth(tenantId);
      alerts.push(...deviceAlerts);

      // Analyze behavioral patterns for security threats
      const behaviorAlerts = await this.analyzeBehaviorPatterns(tenantId);
      alerts.push(...behaviorAlerts);

      // Store alerts in Redis for real-time access
      await this.storePredictiveAlerts(tenantId, alerts);

      return alerts;
    } catch (error) {
      analyticsLogger.error('Predictive alert generation failed', { error, tenantId });
      throw error;
    }
  }

  private async getHistoricalData(tenantId: string, entityType: string, entityId: string): Promise<any[]> {
    const query = {
      index: `access-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              { term: { [`${entityType}Id`]: entityId } },
              { range: { timestamp: { gte: 'now-30d' } } }
            ]
          }
        },
        sort: [{ timestamp: { order: 'desc' } }],
        size: 10000
      }
    };

    const response = await opensearch.search(query);
    return response.body.hits.hits.map((hit: any) => hit._source);
  }

  private async calculateBaseline(historicalData: any[]): Promise<any> {
    // Calculate statistical baseline from historical data
    const hourlyPatterns = new Map<number, number[]>();
    const dailyPatterns = new Map<number, number[]>();
    const locationPatterns = new Map<string, number>();

    historicalData.forEach(event => {
      const date = new Date(event.timestamp);
      const hour = date.getHours();
      const day = date.getDay();
      const location = `${event.buildingId}-${event.floorId}-${event.zoneId}`;

      if (!hourlyPatterns.has(hour)) hourlyPatterns.set(hour, []);
      if (!dailyPatterns.has(day)) dailyPatterns.set(day, []);

      hourlyPatterns.get(hour)!.push(1);
      dailyPatterns.get(day)!.push(1);
      locationPatterns.set(location, (locationPatterns.get(location) || 0) + 1);
    });

    return {
      hourlyPatterns: this.calculateStatistics(hourlyPatterns),
      dailyPatterns: this.calculateStatistics(dailyPatterns),
      locationPatterns,
      totalEvents: historicalData.length,
      avgEventsPerDay: historicalData.length / 30
    };
  }

  private calculateStatistics(patterns: Map<number, number[]>): Map<number, { mean: number; std: number; count: number }> {
    const stats = new Map();
    
    patterns.forEach((values, key) => {
      const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
      const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
      const std = Math.sqrt(variance);
      
      stats.set(key, { mean, std, count: values.length });
    });

    return stats;
  }

  private async getRecentActivity(tenantId: string, entityType: string, entityId: string): Promise<any[]> {
    const query = {
      index: `access-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              { term: { [`${entityType}Id`]: entityId } },
              { range: { timestamp: { gte: 'now-24h' } } }
            ]
          }
        },
        sort: [{ timestamp: { order: 'desc' } }],
        size: 1000
      }
    };

    const response = await opensearch.search(query);
    return response.body.hits.hits.map((hit: any) => hit._source);
  }

  private async calculateAnomalyScore(baseline: any, recentActivity: any[]): Promise<number> {
    let anomalyScore = 0;
    let factors = 0;

    // Check hourly pattern deviation
    const currentHour = new Date().getHours();
    const recentHourlyActivity = recentActivity.filter(event => 
      new Date(event.timestamp).getHours() === currentHour
    ).length;

    const expectedHourly = baseline.hourlyPatterns.get(currentHour)?.mean || 0;
    const hourlyDeviation = Math.abs(recentHourlyActivity - expectedHourly) / (expectedHourly + 1);
    anomalyScore += hourlyDeviation * 0.3;
    factors++;

    // Check location pattern deviation
    const recentLocations = new Map<string, number>();
    recentActivity.forEach(event => {
      const location = `${event.buildingId}-${event.floorId}-${event.zoneId}`;
      recentLocations.set(location, (recentLocations.get(location) || 0) + 1);
    });

    let locationAnomalyScore = 0;
    recentLocations.forEach((count, location) => {
      const expected = baseline.locationPatterns.get(location) || 0;
      const deviation = Math.abs(count - expected) / (expected + 1);
      locationAnomalyScore += deviation;
    });
    anomalyScore += (locationAnomalyScore / recentLocations.size) * 0.4;
    factors++;

    // Check frequency deviation
    const recentFrequency = recentActivity.length;
    const expectedFrequency = baseline.avgEventsPerDay / 24;
    const frequencyDeviation = Math.abs(recentFrequency - expectedFrequency) / (expectedFrequency + 1);
    anomalyScore += frequencyDeviation * 0.3;
    factors++;

    return Math.min(anomalyScore / factors, 1.0);
  }

  private determineSeverity(score: number, threshold: number): 'low' | 'medium' | 'high' | 'critical' {
    if (score < threshold * 0.5) return 'low';
    if (score < threshold) return 'medium';
    if (score < threshold * 1.5) return 'high';
    return 'critical';
  }

  private async identifyAnomalyFactors(baseline: any, recentActivity: any[]): Promise<string[]> {
    const factors: string[] = [];

    // Check for unusual time patterns
    const currentHour = new Date().getHours();
    const recentHourlyActivity = recentActivity.filter(event => 
      new Date(event.timestamp).getHours() === currentHour
    ).length;
    const expectedHourly = baseline.hourlyPatterns.get(currentHour)?.mean || 0;
    
    if (recentHourlyActivity > expectedHourly * 2) {
      factors.push('Unusual high activity for current time');
    } else if (recentHourlyActivity < expectedHourly * 0.5 && expectedHourly > 0) {
      factors.push('Unusual low activity for current time');
    }

    // Check for new locations
    const recentLocations = new Set(recentActivity.map(event => 
      `${event.buildingId}-${event.floorId}-${event.zoneId}`
    ));
    const baselineLocations = new Set(baseline.locationPatterns.keys());
    
    recentLocations.forEach(location => {
      if (!baselineLocations.has(location)) {
        factors.push('Access to new/unusual location');
      }
    });

    // Check for rapid successive access attempts
    const sortedActivity = recentActivity.sort((a, b) => 
      new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
    );
    
    for (let i = 1; i < sortedActivity.length; i++) {
      const timeDiff = new Date(sortedActivity[i].timestamp).getTime() - 
                      new Date(sortedActivity[i-1].timestamp).getTime();
      if (timeDiff < 30000) { // Less than 30 seconds
        factors.push('Rapid successive access attempts');
        break;
      }
    }

    return factors;
  }

  private async storeAnomaly(tenantId: string, anomaly: AnomalyScore): Promise<void> {
    await opensearch.index({
      index: `anomalies-${tenantId}`,
      body: {
        ...anomaly,
        tenantId,
        '@timestamp': new Date().toISOString()
      }
    });
  }

  private async processOccupancyResults(aggregations: any, tenantId: string, buildingId?: string, floorId?: string, zoneId?: string): Promise<OccupancyData[]> {
    const buckets = aggregations.occupancy_over_time.buckets;
    const occupancyData: OccupancyData[] = [];

    // Get capacity information from database
    const capacity = await this.getLocationCapacity(tenantId, buildingId, floorId, zoneId);

    let runningOccupancy = 0;

    buckets.forEach((bucket: any) => {
      runningOccupancy += bucket.net_occupancy.value || 0;
      runningOccupancy = Math.max(0, runningOccupancy); // Ensure non-negative

      occupancyData.push({
        location: {
          buildingId: buildingId || 'all',
          floorId,
          zoneId
        },
        timestamp: new Date(bucket.key),
        count: runningOccupancy,
        capacity,
        utilizationRate: capacity > 0 ? runningOccupancy / capacity : 0
      });
    });

    return occupancyData;
  }

  private async getLocationCapacity(tenantId: string, buildingId?: string, floorId?: string, zoneId?: string): Promise<number> {
    try {
      if (zoneId) {
        const zone = await prisma.zone.findFirst({
          where: { id: zoneId, tenantId }
        });
        return zone?.capacity || 50; // Default zone capacity
      }

      if (floorId) {
        const floor = await prisma.floor.findFirst({
          where: { id: floorId, tenantId },
          include: { zones: true }
        });
        return floor?.zones.reduce((sum, zone) => sum + (zone.capacity || 50), 0) || 200;
      }

      if (buildingId) {
        const building = await prisma.building.findFirst({
          where: { id: buildingId, tenantId },
          include: { floors: { include: { zones: true } } }
        });
        return building?.floors.reduce((sum, floor) => 
          sum + floor.zones.reduce((zoneSum, zone) => zoneSum + (zone.capacity || 50), 0), 0
        ) || 1000;
      }

      // Default tenant capacity
      return 5000;
    } catch (error) {
      analyticsLogger.error('Failed to get location capacity', { error, tenantId, buildingId, floorId, zoneId });
      return 100; // Fallback capacity
    }
  }

  private async analyzeAccessPatterns(tenantId: string): Promise<PredictiveAlert[]> {
    const alerts: PredictiveAlert[] = [];

    // Analyze for potential tailgating
    const tailgatingQuery = {
      index: `access-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              { range: { timestamp: { gte: 'now-1h' } } }
            ]
          }
        },
        aggs: {
          doors: {
            terms: { field: 'doorId' },
            aggs: {
              rapid_access: {
                filter: {
                  range: { timestamp: { gte: 'now-5m' } }
                }
              }
            }
          }
        }
      }
    };

    const response = await opensearch.search(tailgatingQuery);
    
    response.body.aggregations.doors.buckets.forEach((bucket: any) => {
      if (bucket.rapid_access.doc_count > 5) {
        alerts.push({
          id: `tailgating-${bucket.key}-${Date.now()}`,
          type: 'potential_tailgating',
          severity: 'medium',
          message: `Potential tailgating detected at door ${bucket.key}`,
          entityId: bucket.key,
          entityType: 'door',
          probability: 0.7,
          factors: ['Multiple rapid access attempts', 'Short time window'],
          recommendedActions: ['Review video footage', 'Increase security presence'],
          timestamp: new Date()
        });
      }
    });

    return alerts;
  }

  private async analyzeOccupancyTrends(tenantId: string): Promise<PredictiveAlert[]> {
    const alerts: PredictiveAlert[] = [];

    // Get current occupancy levels
    const occupancyData = await this.trackOccupancy(tenantId);
    
    occupancyData.forEach(data => {
      if (data.utilizationRate > 0.9) {
        alerts.push({
          id: `capacity-${data.location.buildingId}-${Date.now()}`,
          type: 'capacity_warning',
          severity: 'high',
          message: `Building approaching capacity limit`,
          entityId: data.location.buildingId,
          entityType: 'building',
          probability: 0.9,
          factors: ['High utilization rate', 'Limited remaining capacity'],
          recommendedActions: ['Monitor entry points', 'Prepare overflow procedures'],
          timestamp: new Date()
        });
      }
    });

    return alerts;
  }

  private async analyzeDeviceHealth(tenantId: string): Promise<PredictiveAlert[]> {
    const alerts: PredictiveAlert[] = [];

    // Analyze device failure patterns
    const devices = await prisma.accessPanel.findMany({
      where: { tenantId },
      include: { doors: true }
    });

    for (const device of devices) {
      // Check for increasing error rates
      const errorQuery = {
        index: `device-events-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { deviceId: device.id } },
                { term: { eventType: 'error' } },
                { range: { timestamp: { gte: 'now-24h' } } }
              ]
            }
          }
        }
      };

      const errorResponse = await opensearch.search(errorQuery);
      const errorCount = errorResponse.body.hits.total.value;

      if (errorCount > 10) {
        alerts.push({
          id: `device-health-${device.id}-${Date.now()}`,
          type: 'device_degradation',
          severity: 'medium',
          message: `Device showing signs of degradation`,
          entityId: device.id,
          entityType: 'device',
          probability: 0.6,
          factors: ['Increasing error rate', 'Performance degradation'],
          recommendedActions: ['Schedule maintenance', 'Monitor closely'],
          timestamp: new Date()
        });
      }
    }

    return alerts;
  }

  private async analyzeBehaviorPatterns(tenantId: string): Promise<PredictiveAlert[]> {
    const alerts: PredictiveAlert[] = [];

    // Analyze for unusual user behavior
    const users = await prisma.user.findMany({
      where: { tenantId },
      take: 100 // Limit for performance
    });

    for (const user of users) {
      const anomaly = await this.detectAnomalies(tenantId, 'user', user.id, 0.7);
      
      if (anomaly.severity === 'high' || anomaly.severity === 'critical') {
        alerts.push({
          id: `behavior-${user.id}-${Date.now()}`,
          type: 'unusual_behavior',
          severity: anomaly.severity,
          message: `Unusual behavior pattern detected for user ${user.email}`,
          entityId: user.id,
          entityType: 'user',
          probability: anomaly.score,
          factors: anomaly.factors,
          recommendedActions: ['Review user activity', 'Contact user for verification'],
          timestamp: new Date()
        });
      }
    }

    return alerts;
  }

  private async storePredictiveAlerts(tenantId: string, alerts: PredictiveAlert[]): Promise<void> {
    const pipeline = redis.pipeline();
    
    alerts.forEach(alert => {
      pipeline.setex(`alert:${tenantId}:${alert.id}`, 3600, JSON.stringify(alert));
    });
    
    await pipeline.exec();
  }

  // Advanced Video Analytics Methods
  async configureVideoAnalytics(tenantId: string, config: VideoAnalyticsConfig): Promise<void> {
    try {
      // Validate camera exists and belongs to tenant
      const camera = await prisma.camera.findFirst({
        where: { id: config.cameraId, tenantId }
      });

      if (!camera) {
        throw new Error('Camera not found or access denied');
      }

      // Store configuration
      this.videoAnalyticsConfigs.set(config.cameraId, config);

      // Store in database
      await prisma.videoAnalyticsConfig.upsert({
        where: { cameraId: config.cameraId },
        update: {
          faceRecognition: config.faceRecognition,
          licensePlateRecognition: config.licensePlateRecognition,
          behaviorAnalysis: config.behaviorAnalysis,
          zones: config.zones
        },
        create: {
          cameraId: config.cameraId,
          tenantId,
          faceRecognition: config.faceRecognition,
          licensePlateRecognition: config.licensePlateRecognition,
          behaviorAnalysis: config.behaviorAnalysis,
          zones: config.zones
        }
      });

      // Initialize ML models if needed
      await this.initializeMLModels(config);

      analyticsLogger.info('Video analytics configured', { cameraId: config.cameraId, tenantId });
    } catch (error) {
      analyticsLogger.error('Failed to configure video analytics', { error, tenantId, cameraId: config.cameraId });
      throw error;
    }
  }

  async processFaceRecognitionEvent(tenantId: string, event: FaceRecognitionEvent): Promise<void> {
    try {
      // Check if face recognition is enabled for this camera
      const config = this.videoAnalyticsConfigs.get(event.cameraId);
      if (!config?.faceRecognition.enabled) {
        return;
      }

      // Perform face matching if features are provided
      if (event.features) {
        const matchResult = await this.matchFace(event.features, config.faceRecognition.confidence);
        if (matchResult) {
          event.personId = matchResult.personId;
          event.isWatchlisted = this.faceWatchlist.has(matchResult.personId);
        }
      }

      // Store event in OpenSearch
      await opensearch.index({
        index: `face-recognition-${tenantId}`,
        body: {
          ...event,
          tenantId,
          '@timestamp': event.timestamp
        }
      });

      // Generate alerts for watchlisted individuals
      if (event.isWatchlisted) {
        await this.generateFaceRecognitionAlert(tenantId, event);
      }

      // Update person tracking
      if (event.personId) {
        await this.updatePersonTracking(tenantId, event);
      }

      analyticsLogger.info('Face recognition event processed', { 
        cameraId: event.cameraId, 
        personId: event.personId,
        isWatchlisted: event.isWatchlisted 
      });
    } catch (error) {
      analyticsLogger.error('Failed to process face recognition event', { error, event });
      throw error;
    }
  }

  async processLicensePlateEvent(tenantId: string, event: LicensePlateEvent): Promise<void> {
    try {
      // Check if license plate recognition is enabled for this camera
      const config = this.videoAnalyticsConfigs.get(event.cameraId);
      if (!config?.licensePlateRecognition.enabled) {
        return;
      }

      // Check against watchlist
      event.isWatchlisted = this.licensePlateWatchlist.has(event.plateNumber);

      // Store event in OpenSearch
      await opensearch.index({
        index: `license-plate-${tenantId}`,
        body: {
          ...event,
          tenantId,
          '@timestamp': event.timestamp
        }
      });

      // Generate alerts for watchlisted plates
      if (event.isWatchlisted) {
        await this.generateLicensePlateAlert(tenantId, event);
      }

      // Correlate with access control events
      await this.correlateLicensePlateWithAccess(tenantId, event);

      analyticsLogger.info('License plate event processed', { 
        cameraId: event.cameraId, 
        plateNumber: event.plateNumber,
        isWatchlisted: event.isWatchlisted 
      });
    } catch (error) {
      analyticsLogger.error('Failed to process license plate event', { error, event });
      throw error;
    }
  }

  async processBehaviorEvent(tenantId: string, event: BehaviorEvent): Promise<void> {
    try {
      // Check if behavior analysis is enabled for this camera
      const config = this.videoAnalyticsConfigs.get(event.cameraId);
      if (!config?.behaviorAnalysis) {
        return;
      }

      // Validate event type is enabled
      const isEnabled = this.isBehaviorAnalysisEnabled(config, event.eventType);
      if (!isEnabled) {
        return;
      }

      // Store event in OpenSearch
      await opensearch.index({
        index: `behavior-events-${tenantId}`,
        body: {
          ...event,
          tenantId,
          '@timestamp': event.timestamp
        }
      });

      // Generate alerts based on severity
      if (event.severity === 'high' || event.severity === 'critical') {
        await this.generateBehaviorAlert(tenantId, event);
      }

      // Update behavior patterns
      await this.updateBehaviorPatterns(tenantId, event);

      analyticsLogger.info('Behavior event processed', { 
        cameraId: event.cameraId, 
        eventType: event.eventType,
        severity: event.severity 
      });
    } catch (error) {
      analyticsLogger.error('Failed to process behavior event', { error, event });
      throw error;
    }
  }

  async performCrowdAnalysis(tenantId: string, cameraId: string): Promise<CrowdAnalysis> {
    try {
      const config = this.videoAnalyticsConfigs.get(cameraId);
      if (!config?.behaviorAnalysis.crowdAnalysis) {
        throw new Error('Crowd analysis not enabled for this camera');
      }

      // Get recent person detection events
      const recentEvents = await this.getRecentPersonDetections(tenantId, cameraId, 300); // Last 5 minutes

      // Analyze crowd density and movement
      const analysis = await this.analyzeCrowdMetrics(recentEvents, config);

      // Store analysis results
      await opensearch.index({
        index: `crowd-analysis-${tenantId}`,
        body: {
          ...analysis,
          tenantId,
          '@timestamp': new Date().toISOString()
        }
      });

      // Generate alerts if risk level is high
      if (analysis.riskLevel === 'high' || analysis.riskLevel === 'critical') {
        await this.generateCrowdAlert(tenantId, analysis);
      }

      return analysis;
    } catch (error) {
      analyticsLogger.error('Crowd analysis failed', { error, tenantId, cameraId });
      throw error;
    }
  }

  async generateIncidentPredictions(tenantId: string): Promise<IncidentPrediction[]> {
    try {
      const predictions: IncidentPrediction[] = [];

      // Analyze patterns for security breach prediction
      const securityPredictions = await this.predictSecurityBreaches(tenantId);
      predictions.push(...securityPredictions);

      // Analyze crowd patterns for incident prediction
      const crowdPredictions = await this.predictCrowdIncidents(tenantId);
      predictions.push(...crowdPredictions);

      // Analyze equipment patterns for failure prediction
      const equipmentPredictions = await this.predictEquipmentFailures(tenantId);
      predictions.push(...equipmentPredictions);

      // Analyze safety patterns for violation prediction
      const safetyPredictions = await this.predictSafetyViolations(tenantId);
      predictions.push(...safetyPredictions);

      // Store predictions
      for (const prediction of predictions) {
        await opensearch.index({
          index: `incident-predictions-${tenantId}`,
          body: {
            ...prediction,
            tenantId,
            '@timestamp': prediction.timestamp.toISOString()
          }
        });
      }

      return predictions;
    } catch (error) {
      analyticsLogger.error('Incident prediction failed', { error, tenantId });
      throw error;
    }
  }

  async enrollFace(tenantId: string, personId: string, features: number[], metadata: any = {}): Promise<void> {
    try {
      // Store face features in database
      await prisma.faceEnrollment.create({
        data: {
          personId,
          tenantId,
          features,
          metadata,
          enrolledAt: new Date()
        }
      });

      // Update in-memory database
      this.faceDatabase.set(`${tenantId}:${personId}`, {
        personId,
        features,
        metadata
      });

      analyticsLogger.info('Face enrolled', { tenantId, personId });
    } catch (error) {
      analyticsLogger.error('Face enrollment failed', { error, tenantId, personId });
      throw error;
    }
  }

  async updateWatchlists(tenantId: string, type: 'face' | 'license_plate', items: string[]): Promise<void> {
    try {
      if (type === 'face') {
        // Update face watchlist
        this.faceWatchlist.clear();
        items.forEach(personId => this.faceWatchlist.add(personId));
        
        await prisma.faceWatchlist.deleteMany({ where: { tenantId } });
        await prisma.faceWatchlist.createMany({
          data: items.map(personId => ({ tenantId, personId }))
        });
      } else {
        // Update license plate watchlist
        this.licensePlateWatchlist.clear();
        items.forEach(plate => this.licensePlateWatchlist.add(plate));
        
        await prisma.licensePlateWatchlist.deleteMany({ where: { tenantId } });
        await prisma.licensePlateWatchlist.createMany({
          data: items.map(plateNumber => ({ tenantId, plateNumber }))
        });
      }

      analyticsLogger.info('Watchlist updated', { tenantId, type, count: items.length });
    } catch (error) {
      analyticsLogger.error('Watchlist update failed', { error, tenantId, type });
      throw error;
    }
  }

  // Private helper methods for advanced video analytics
  private async initializeMLModels(config: VideoAnalyticsConfig): Promise<void> {
    try {
      // Initialize face recognition model
      if (config.faceRecognition.enabled) {
        const faceModel: MLModelConfig = {
          modelId: `face-recognition-${config.cameraId}`,
          modelType: 'face_recognition',
          version: '1.0',
          endpoint: process.env.FACE_RECOGNITION_ENDPOINT || 'http://localhost:8001/face-recognition',
          confidence: config.faceRecognition.confidence,
          enabled: true
        };
        this.mlModels.set(faceModel.modelId, faceModel);
      }

      // Initialize license plate recognition model
      if (config.licensePlateRecognition.enabled) {
        const lprModel: MLModelConfig = {
          modelId: `lpr-${config.cameraId}`,
          modelType: 'license_plate',
          version: '1.0',
          endpoint: process.env.LPR_ENDPOINT || 'http://localhost:8002/license-plate',
          confidence: config.licensePlateRecognition.confidence,
          enabled: true
        };
        this.mlModels.set(lprModel.modelId, lprModel);
      }

      // Initialize behavior analysis model
      if (config.behaviorAnalysis.loiteringDetection || config.behaviorAnalysis.crowdAnalysis) {
        const behaviorModel: MLModelConfig = {
          modelId: `behavior-${config.cameraId}`,
          modelType: 'behavior_analysis',
          version: '1.0',
          endpoint: process.env.BEHAVIOR_ANALYSIS_ENDPOINT || 'http://localhost:8003/behavior',
          confidence: 0.7,
          enabled: true
        };
        this.mlModels.set(behaviorModel.modelId, behaviorModel);
      }
    } catch (error) {
      analyticsLogger.error('ML model initialization failed', { error, cameraId: config.cameraId });
      throw error;
    }
  }

  private async matchFace(features: number[], confidence: number): Promise<{ personId: string; similarity: number } | null> {
    try {
      let bestMatch: { personId: string; similarity: number } | null = null;

      // Compare with enrolled faces
      for (const [key, enrollment] of this.faceDatabase) {
        const similarity = this.calculateCosineSimilarity(features, enrollment.features);
        
        if (similarity >= confidence && (!bestMatch || similarity > bestMatch.similarity)) {
          bestMatch = {
            personId: enrollment.personId,
            similarity
          };
        }
      }

      return bestMatch;
    } catch (error) {
      analyticsLogger.error('Face matching failed', { error });
      return null;
    }
  }

  private calculateCosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) return 0;

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }

    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  private async generateFaceRecognitionAlert(tenantId: string, event: FaceRecognitionEvent): Promise<void> {
    const alert: PredictiveAlert = {
      id: `face-alert-${event.id}-${Date.now()}`,
      type: 'watchlist_face_detected',
      severity: 'high',
      message: `Watchlisted individual detected on camera ${event.cameraId}`,
      entityId: event.cameraId,
      entityType: 'camera',
      probability: event.confidence,
      factors: ['Face recognition match', 'Watchlist entry'],
      recommendedActions: ['Verify identity', 'Dispatch security', 'Review access logs'],
      timestamp: new Date()
    };

    await this.storeAlert(tenantId, alert);
  }

  private async generateLicensePlateAlert(tenantId: string, event: LicensePlateEvent): Promise<void> {
    const alert: PredictiveAlert = {
      id: `lpr-alert-${event.id}-${Date.now()}`,
      type: 'watchlist_plate_detected',
      severity: 'high',
      message: `Watchlisted license plate ${event.plateNumber} detected on camera ${event.cameraId}`,
      entityId: event.cameraId,
      entityType: 'camera',
      probability: event.confidence,
      factors: ['License plate recognition match', 'Watchlist entry'],
      recommendedActions: ['Verify vehicle', 'Check access authorization', 'Monitor vehicle movement'],
      timestamp: new Date()
    };

    await this.storeAlert(tenantId, alert);
  }

  private async generateBehaviorAlert(tenantId: string, event: BehaviorEvent): Promise<void> {
    const alert: PredictiveAlert = {
      id: `behavior-alert-${event.id}-${Date.now()}`,
      type: `behavior_${event.eventType}`,
      severity: event.severity,
      message: `${event.eventType.replace('_', ' ')} detected on camera ${event.cameraId}`,
      entityId: event.cameraId,
      entityType: 'camera',
      probability: event.confidence,
      factors: ['Behavior analysis detection', `Event type: ${event.eventType}`],
      recommendedActions: this.getBehaviorRecommendations(event.eventType),
      timestamp: new Date()
    };

    await this.storeAlert(tenantId, alert);
  }

  private async generateCrowdAlert(tenantId: string, analysis: CrowdAnalysis): Promise<void> {
    const alert: PredictiveAlert = {
      id: `crowd-alert-${analysis.cameraId}-${Date.now()}`,
      type: 'crowd_risk',
      severity: analysis.riskLevel,
      message: `High crowd density detected on camera ${analysis.cameraId}`,
      entityId: analysis.cameraId,
      entityType: 'camera',
      probability: 0.9,
      factors: [`Crowd count: ${analysis.totalCount}`, `Density: ${analysis.density}`, `Risk level: ${analysis.riskLevel}`],
      recommendedActions: ['Monitor crowd movement', 'Prepare crowd control measures', 'Alert security personnel'],
      timestamp: new Date()
    };

    await this.storeAlert(tenantId, alert);
  }

  private getBehaviorRecommendations(eventType: string): string[] {
    const recommendations: Record<string, string[]> = {
      loitering: ['Investigate area', 'Approach individual', 'Review access authorization'],
      crowd_formation: ['Monitor crowd behavior', 'Prepare crowd control', 'Alert security'],
      unusual_direction: ['Verify access route', 'Check for unauthorized access', 'Monitor individual'],
      speed_violation: ['Check for emergency', 'Verify safety protocols', 'Monitor area'],
      object_left: ['Investigate object', 'Check for security threat', 'Secure area'],
      object_removed: ['Verify authorization', 'Check inventory', 'Review access logs']
    };

    return recommendations[eventType] || ['Monitor situation', 'Alert security'];
  }

  private async storeAlert(tenantId: string, alert: PredictiveAlert): Promise<void> {
    await redis.setex(`alert:${tenantId}:${alert.id}`, 3600, JSON.stringify(alert));
    
    // Also store in OpenSearch for historical analysis
    await opensearch.index({
      index: `alerts-${tenantId}`,
      body: {
        ...alert,
        tenantId,
        '@timestamp': alert.timestamp.toISOString()
      }
    });
  }

  private isBehaviorAnalysisEnabled(config: VideoAnalyticsConfig, eventType: string): boolean {
    switch (eventType) {
      case 'loitering':
        return config.behaviorAnalysis.loiteringDetection;
      case 'crowd_formation':
        return config.behaviorAnalysis.crowdAnalysis;
      case 'unusual_direction':
        return config.behaviorAnalysis.directionAnalysis;
      case 'speed_violation':
        return config.behaviorAnalysis.speedAnalysis;
      default:
        return true; // Enable other event types by default
    }
  }

  private async updatePersonTracking(tenantId: string, event: FaceRecognitionEvent): Promise<void> {
    try {
      // Update person location tracking
      await redis.setex(
        `person:${tenantId}:${event.personId}:location`,
        3600,
        JSON.stringify({
          cameraId: event.cameraId,
          timestamp: event.timestamp,
          confidence: event.confidence
        })
      );

      // Store in person tracking index
      await opensearch.index({
        index: `person-tracking-${tenantId}`,
        body: {
          personId: event.personId,
          cameraId: event.cameraId,
          timestamp: event.timestamp,
          confidence: event.confidence,
          tenantId,
          '@timestamp': event.timestamp
        }
      });
    } catch (error) {
      analyticsLogger.error('Person tracking update failed', { error, event });
    }
  }

  private async correlateLicensePlateWithAccess(tenantId: string, event: LicensePlateEvent): Promise<void> {
    try {
      // Look for recent access events near this camera
      const camera = await prisma.camera.findFirst({
        where: { id: event.cameraId, tenantId },
        include: { building: true, floor: true, zone: true }
      });

      if (!camera) return;

      // Search for access events in the same area within the last 10 minutes
      const recentAccessEvents = await opensearch.search({
        index: `access-events-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { range: { timestamp: { gte: 'now-10m' } } },
                {
                  bool: {
                    should: [
                      { term: { buildingId: camera.buildingId } },
                      { term: { floorId: camera.floorId } },
                      { term: { zoneId: camera.zoneId } }
                    ]
                  }
                }
              ]
            }
          },
          sort: [{ timestamp: { order: 'desc' } }],
          size: 10
        }
      });

      // Create correlation records
      for (const hit of recentAccessEvents.body.hits.hits) {
        await opensearch.index({
          index: `vehicle-access-correlation-${tenantId}`,
          body: {
            plateNumber: event.plateNumber,
            accessEventId: hit._source.id,
            cameraId: event.cameraId,
            userId: hit._source.userId,
            timestamp: event.timestamp,
            confidence: event.confidence,
            tenantId,
            '@timestamp': event.timestamp
          }
        });
      }
    } catch (error) {
      analyticsLogger.error('License plate correlation failed', { error, event });
    }
  }

  private async updateBehaviorPatterns(tenantId: string, event: BehaviorEvent): Promise<void> {
    try {
      const patternKey = `behavior:${tenantId}:${event.cameraId}:${event.eventType}`;
      
      // Get existing pattern data
      const existingPattern = await redis.get(patternKey);
      let pattern = existingPattern ? JSON.parse(existingPattern) : {
        eventType: event.eventType,
        cameraId: event.cameraId,
        count: 0,
        averageConfidence: 0,
        lastOccurrence: null,
        frequency: 0
      };

      // Update pattern
      pattern.count++;
      pattern.averageConfidence = (pattern.averageConfidence * (pattern.count - 1) + event.confidence) / pattern.count;
      pattern.lastOccurrence = event.timestamp;
      pattern.frequency = pattern.count / Math.max(1, (Date.now() - new Date(pattern.lastOccurrence).getTime()) / (24 * 60 * 60 * 1000));

      // Store updated pattern
      await redis.setex(patternKey, 86400, JSON.stringify(pattern)); // 24 hour expiry
    } catch (error) {
      analyticsLogger.error('Behavior pattern update failed', { error, event });
    }
  }

  private async getRecentPersonDetections(tenantId: string, cameraId: string, seconds: number): Promise<any[]> {
    try {
      const response = await opensearch.search({
        index: `face-recognition-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { term: { cameraId } },
                { range: { timestamp: { gte: `now-${seconds}s` } } }
              ]
            }
          },
          sort: [{ timestamp: { order: 'desc' } }],
          size: 1000
        }
      });

      return response.body.hits.hits.map((hit: any) => hit._source);
    } catch (error) {
      analyticsLogger.error('Failed to get recent person detections', { error, tenantId, cameraId });
      return [];
    }
  }

  private async analyzeCrowdMetrics(events: any[], config: VideoAnalyticsConfig): Promise<CrowdAnalysis> {
    try {
      const totalCount = events.length;
      const timestamp = new Date();

      // Calculate density (simplified - would use actual area in production)
      const density = totalCount / 100; // Assuming 100 sq meter area

      // Calculate average speed (simplified)
      const averageSpeed = this.calculateAverageSpeed(events);

      // Calculate flow direction
      const flowDirection = this.calculateFlowDirection(events);

      // Identify hotspots
      const hotspots = this.identifyHotspots(events);

      // Determine risk level
      const riskLevel = this.determineRiskLevel(totalCount, density, config);

      return {
        cameraId: config.cameraId,
        timestamp,
        totalCount,
        density,
        averageSpeed,
        flowDirection,
        hotspots,
        riskLevel
      };
    } catch (error) {
      analyticsLogger.error('Crowd metrics analysis failed', { error });
      throw error;
    }
  }

  private calculateAverageSpeed(events: any[]): number {
    // Simplified speed calculation - would track movement between frames in production
    return events.length > 0 ? Math.random() * 2 + 1 : 0; // 1-3 m/s
  }

  private calculateFlowDirection(events: any[]): { angle: number; magnitude: number } {
    // Simplified flow direction calculation
    return {
      angle: Math.random() * 360,
      magnitude: Math.random()
    };
  }

  private identifyHotspots(events: any[]): Array<{ x: number; y: number; intensity: number }> {
    // Simplified hotspot identification
    const hotspots: Array<{ x: number; y: number; intensity: number }> = [];
    
    // Group events by location and calculate intensity
    const locationMap = new Map<string, number>();
    
    events.forEach(event => {
      if (event.boundingBox) {
        const x = Math.floor(event.boundingBox.x / 0.1) * 0.1;
        const y = Math.floor(event.boundingBox.y / 0.1) * 0.1;
        const key = `${x},${y}`;
        locationMap.set(key, (locationMap.get(key) || 0) + 1);
      }
    });

    // Convert to hotspots
    locationMap.forEach((count, key) => {
      const [x, y] = key.split(',').map(Number);
      if (count > 2) { // Threshold for hotspot
        hotspots.push({ x, y, intensity: count / events.length });
      }
    });

    return hotspots;
  }

  private determineRiskLevel(count: number, density: number, config: VideoAnalyticsConfig): 'low' | 'medium' | 'high' | 'critical' {
    const threshold = config.behaviorAnalysis.crowdThreshold;
    
    if (count > threshold * 2 || density > 0.8) return 'critical';
    if (count > threshold * 1.5 || density > 0.6) return 'high';
    if (count > threshold || density > 0.4) return 'medium';
    return 'low';
  }

  private async predictSecurityBreaches(tenantId: string): Promise<IncidentPrediction[]> {
    const predictions: IncidentPrediction[] = [];

    try {
      // Analyze failed access attempts
      const failedAttempts = await opensearch.search({
        index: `access-events-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { term: { granted: false } },
                { range: { timestamp: { gte: 'now-1h' } } }
              ]
            }
          },
          aggs: {
            by_door: {
              terms: { field: 'doorId', size: 10 }
            },
            by_user: {
              terms: { field: 'userId', size: 10 }
            }
          }
        }
      });

      // Check for suspicious patterns
      failedAttempts.body.aggregations.by_door.buckets.forEach((bucket: any) => {
        if (bucket.doc_count > 5) {
          predictions.push({
            id: `security-breach-${bucket.key}-${Date.now()}`,
            type: 'security_breach',
            probability: Math.min(bucket.doc_count / 10, 0.9),
            timeToIncident: 30,
            location: {
              buildingId: 'unknown',
              doorId: bucket.key
            },
            factors: [`${bucket.doc_count} failed access attempts`, 'Potential brute force attack'],
            recommendedActions: ['Increase security presence', 'Review access logs', 'Check door status'],
            severity: bucket.doc_count > 10 ? 'critical' : 'high',
            timestamp: new Date()
          });
        }
      });
    } catch (error) {
      analyticsLogger.error('Security breach prediction failed', { error, tenantId });
    }

    return predictions;
  }

  private async predictCrowdIncidents(tenantId: string): Promise<IncidentPrediction[]> {
    const predictions: IncidentPrediction[] = [];

    try {
      // Analyze crowd analysis data
      const crowdData = await opensearch.search({
        index: `crowd-analysis-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { range: { timestamp: { gte: 'now-30m' } } }
              ]
            }
          },
          sort: [{ timestamp: { order: 'desc' } }],
          size: 100
        }
      });

      // Analyze trends
      const analyses = crowdData.body.hits.hits.map((hit: any) => hit._source);
      const highRiskCameras = analyses.filter((analysis: any) => 
        analysis.riskLevel === 'high' || analysis.riskLevel === 'critical'
      );

      highRiskCameras.forEach((analysis: any) => {
        predictions.push({
          id: `crowd-incident-${analysis.cameraId}-${Date.now()}`,
          type: 'crowd_incident',
          probability: analysis.riskLevel === 'critical' ? 0.8 : 0.6,
          timeToIncident: 15,
          location: {
            buildingId: 'unknown',
            cameraId: analysis.cameraId
          },
          factors: [`High crowd density: ${analysis.density}`, `Total count: ${analysis.totalCount}`],
          recommendedActions: ['Deploy crowd control', 'Monitor exits', 'Prepare emergency procedures'],
          severity: analysis.riskLevel === 'critical' ? 'critical' : 'high',
          timestamp: new Date()
        });
      });
    } catch (error) {
      analyticsLogger.error('Crowd incident prediction failed', { error, tenantId });
    }

    return predictions;
  }

  private async predictEquipmentFailures(tenantId: string): Promise<IncidentPrediction[]> {
    const predictions: IncidentPrediction[] = [];

    try {
      // Analyze device error patterns
      const deviceErrors = await opensearch.search({
        index: `device-events-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { term: { eventType: 'error' } },
                { range: { timestamp: { gte: 'now-24h' } } }
              ]
            }
          },
          aggs: {
            by_device: {
              terms: { field: 'deviceId', size: 20 }
            }
          }
        }
      });

      deviceErrors.body.aggregations.by_device.buckets.forEach((bucket: any) => {
        if (bucket.doc_count > 5) {
          predictions.push({
            id: `equipment-failure-${bucket.key}-${Date.now()}`,
            type: 'equipment_failure',
            probability: Math.min(bucket.doc_count / 20, 0.8),
            timeToIncident: 120,
            location: {
              buildingId: 'unknown'
            },
            factors: [`${bucket.doc_count} error events`, 'Increasing failure rate'],
            recommendedActions: ['Schedule maintenance', 'Check device status', 'Prepare replacement'],
            severity: bucket.doc_count > 15 ? 'high' : 'medium',
            timestamp: new Date()
          });
        }
      });
    } catch (error) {
      analyticsLogger.error('Equipment failure prediction failed', { error, tenantId });
    }

    return predictions;
  }

  private async predictSafetyViolations(tenantId: string): Promise<IncidentPrediction[]> {
    const predictions: IncidentPrediction[] = [];

    try {
      // Analyze behavior events for safety patterns
      const behaviorEvents = await opensearch.search({
        index: `behavior-events-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { terms: { eventType: ['speed_violation', 'object_left', 'unusual_direction'] } },
                { range: { timestamp: { gte: 'now-2h' } } }
              ]
            }
          },
          aggs: {
            by_camera: {
              terms: { field: 'cameraId', size: 10 }
            }
          }
        }
      });

      behaviorEvents.body.aggregations.by_camera.buckets.forEach((bucket: any) => {
        if (bucket.doc_count > 3) {
          predictions.push({
            id: `safety-violation-${bucket.key}-${Date.now()}`,
            type: 'safety_violation',
            probability: Math.min(bucket.doc_count / 10, 0.7),
            timeToIncident: 60,
            location: {
              buildingId: 'unknown',
              cameraId: bucket.key
            },
            factors: [`${bucket.doc_count} safety-related events`, 'Pattern of violations'],
            recommendedActions: ['Review safety protocols', 'Increase monitoring', 'Safety briefing'],
            severity: bucket.doc_count > 6 ? 'high' : 'medium',
            timestamp: new Date()
          });
        }
      });
    } catch (error) {
      analyticsLogger.error('Safety violation prediction failed', { error, tenantId });
    }

    return predictions;
  }
}

// Initialize analytics engine
const analyticsEngine = new AnalyticsEngine();

// Middleware
app.use('*', cors({
  origin: process.env.CORS_ORIGIN || '*',
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization', 'X-Tenant-ID']
}));

app.use('*', logger());
app.use('*', prettyJSON());

// Authentication middleware
app.use('*', async (c, next) => {
  if (c.req.path === '/health') {
    return next();
  }

  const authorization = c.req.header('Authorization');
  if (!authorization?.startsWith('Bearer ')) {
    throw new HTTPException(401, { message: 'Missing or invalid authorization header' });
  }

  const token = authorization.substring(7);
  try {
    // Verify JWT token (implementation would use actual JWT verification)
    const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
    c.set('user', payload);
    c.set('tenantId', payload.tenantId);
  } catch (error) {
    throw new HTTPException(401, { message: 'Invalid token' });
  }

  await next();
});

// Health check endpoint
app.get('/health', (c) => {
  return c.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    service: 'analytics-service',
    version: '1.0.0'
  });
});

// Analytics endpoints

// Get security analytics
app.get('/analytics/security', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const query = AnalyticsQuerySchema.parse(c.req.query());

    const securityMetrics = await opensearch.search({
      index: `access-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [])
            ]
          }
        },
        aggs: {
          access_attempts: {
            terms: { field: 'granted' }
          },
          hourly_distribution: {
            date_histogram: {
              field: 'timestamp',
              interval: '1h'
            }
          },
          top_doors: {
            terms: { field: 'doorId', size: 10 }
          },
          failed_attempts: {
            filter: { term: { granted: false } },
            aggs: {
              by_user: {
                terms: { field: 'userId', size: 10 }
              }
            }
          }
        }
      }
    });

    return c.json({
      success: true,
      data: {
        totalEvents: securityMetrics.body.hits.total.value,
        accessAttempts: securityMetrics.body.aggregations.access_attempts.buckets,
        hourlyDistribution: securityMetrics.body.aggregations.hourly_distribution.buckets,
        topDoors: securityMetrics.body.aggregations.top_doors.buckets,
        failedAttempts: securityMetrics.body.aggregations.failed_attempts
      }
    });
  } catch (error) {
    analyticsLogger.error('Security analytics failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve security analytics' });
  }
});

// Get occupancy analytics
app.get('/analytics/occupancy', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const query = OccupancyQuerySchema.parse(c.req.query());

    const occupancyData = await analyticsEngine.trackOccupancy(
      tenantId,
      query.buildingId,
      query.floorId,
      query.zoneId
    );

    return c.json({
      success: true,
      data: occupancyData
    });
  } catch (error) {
    analyticsLogger.error('Occupancy analytics failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve occupancy analytics' });
  }
});

// Detect anomalies
app.post('/analytics/anomalies', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const body = AnomalyDetectionSchema.parse(await c.req.json());

    const anomaly = await analyticsEngine.detectAnomalies(
      tenantId,
      body.entityType,
      body.entityId,
      body.threshold
    );

    return c.json({
      success: true,
      data: anomaly
    });
  } catch (error) {
    analyticsLogger.error('Anomaly detection failed', { error });
    throw new HTTPException(500, { message: 'Failed to detect anomalies' });
  }
});

// Get predictive alerts
app.get('/analytics/alerts/predictive', async (c) => {
  try {
    const tenantId = c.get('tenantId');

    const alerts = await analyticsEngine.generatePredictiveAlerts(tenantId);

    return c.json({
      success: true,
      data: alerts
    });
  } catch (error) {
    analyticsLogger.error('Predictive alerts failed', { error });
    throw new HTTPException(500, { message: 'Failed to generate predictive alerts' });
  }
});

// Get behavioral analysis
app.get('/analytics/behavior/:entityType/:entityId', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const entityType = c.req.param('entityType');
    const entityId = c.req.param('entityId');

    const behaviorAnalysis = await opensearch.search({
      index: `access-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              { term: { [`${entityType}Id`]: entityId } },
              { range: { timestamp: { gte: 'now-30d' } } }
            ]
          }
        },
        aggs: {
          daily_pattern: {
            date_histogram: {
              field: 'timestamp',
              interval: 'day'
            }
          },
          hourly_pattern: {
            date_histogram: {
              field: 'timestamp',
              interval: 'hour'
            }
          },
          location_pattern: {
            terms: { field: 'doorId', size: 20 }
          },
          access_success_rate: {
            terms: { field: 'granted' }
          }
        }
      }
    });

    return c.json({
      success: true,
      data: {
        totalEvents: behaviorAnalysis.body.hits.total.value,
        dailyPattern: behaviorAnalysis.body.aggregations.daily_pattern.buckets,
        hourlyPattern: behaviorAnalysis.body.aggregations.hourly_pattern.buckets,
        locationPattern: behaviorAnalysis.body.aggregations.location_pattern.buckets,
        successRate: behaviorAnalysis.body.aggregations.access_success_rate.buckets
      }
    });
  } catch (error) {
    analyticsLogger.error('Behavioral analysis failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve behavioral analysis' });
  }
});

// Get trend analysis
app.get('/analytics/trends', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const query = AnalyticsQuerySchema.parse(c.req.query());

    const trends = await opensearch.search({
      index: `access-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [{ range: { timestamp: { gte: 'now-30d' } } }])
            ]
          }
        },
        aggs: {
          daily_trends: {
            date_histogram: {
              field: 'timestamp',
              interval: 'day'
            },
            aggs: {
              access_granted: {
                filter: { term: { granted: true } }
              },
              access_denied: {
                filter: { term: { granted: false } }
              },
              unique_users: {
                cardinality: { field: 'userId' }
              }
            }
          },
          weekly_comparison: {
            date_histogram: {
              field: 'timestamp',
              interval: 'week'
            }
          }
        }
      }
    });

    return c.json({
      success: true,
      data: {
        dailyTrends: trends.body.aggregations.daily_trends.buckets,
        weeklyComparison: trends.body.aggregations.weekly_comparison.buckets
      }
    });
  } catch (error) {
    analyticsLogger.error('Trend analysis failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve trend analysis' });
  }
});

// Real-time analytics dashboard data
app.get('/analytics/dashboard', async (c) => {
  try {
    const tenantId = c.get('tenantId');

    // Get real-time metrics from Redis cache
    const cachedMetrics = await redis.get(`dashboard:${tenantId}`);
    if (cachedMetrics) {
      return c.json({
        success: true,
        data: JSON.parse(cachedMetrics),
        cached: true
      });
    }

    // Generate fresh dashboard data
    const [securityMetrics, occupancyData, recentAlerts] = await Promise.all([
      opensearch.search({
        index: `access-events-${tenantId}`,
        body: {
          query: {
            bool: {
              must: [
                { term: { tenantId } },
                { range: { timestamp: { gte: 'now-24h' } } }
              ]
            }
          },
          aggs: {
            total_events: { value_count: { field: 'timestamp' } },
            success_rate: {
              terms: { field: 'granted' }
            },
            active_doors: {
              cardinality: { field: 'doorId' }
            },
            unique_users: {
              cardinality: { field: 'userId' }
            }
          }
        }
      }),
      analyticsEngine.trackOccupancy(tenantId),
      redis.keys(`alert:${tenantId}:*`).then(keys => 
        keys.length > 0 ? redis.mget(keys) : []
      )
    ]);

    const dashboardData = {
      timestamp: new Date().toISOString(),
      security: {
        totalEvents: securityMetrics.body.aggregations.total_events.value,
        successRate: securityMetrics.body.aggregations.success_rate.buckets,
        activeDoors: securityMetrics.body.aggregations.active_doors.value,
        uniqueUsers: securityMetrics.body.aggregations.unique_users.value
      },
      occupancy: occupancyData.slice(-24), // Last 24 hours
      alerts: recentAlerts.filter(alert => alert).map(alert => JSON.parse(alert)).slice(0, 10)
    };

    // Cache for 1 minute
    await redis.setex(`dashboard:${tenantId}`, 60, JSON.stringify(dashboardData));

    return c.json({
      success: true,
      data: dashboardData,
      cached: false
    });
  } catch (error) {
    analyticsLogger.error('Dashboard data failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve dashboard data' });
  }
});

// Advanced Video Analytics Endpoints

// Configure video analytics for a camera
app.post('/analytics/video/configure', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const body = await c.req.json();
    const config = VideoAnalyticsConfigSchema.parse(body);

    await analyticsEngine.configureVideoAnalytics(tenantId, config);

    return c.json({
      success: true,
      message: 'Video analytics configured successfully'
    });
  } catch (error) {
    analyticsLogger.error('Video analytics configuration failed', { error });
    throw new HTTPException(500, { message: 'Failed to configure video analytics' });
  }
});

// Process face recognition event
app.post('/analytics/video/face-recognition', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const body = await c.req.json();
    const event = FaceRecognitionEventSchema.parse(body);

    const faceEvent: FaceRecognitionEvent = {
      id: `face-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      tenantId,
      ...event,
      timestamp: new Date(event.timestamp)
    };

    await analyticsEngine.processFaceRecognitionEvent(tenantId, faceEvent);

    return c.json({
      success: true,
      eventId: faceEvent.id,
      message: 'Face recognition event processed'
    });
  } catch (error) {
    analyticsLogger.error('Face recognition processing failed', { error });
    throw new HTTPException(500, { message: 'Failed to process face recognition event' });
  }
});

// Process license plate recognition event
app.post('/analytics/video/license-plate', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const body = await c.req.json();
    const event = LicensePlateEventSchema.parse(body);

    const lprEvent: LicensePlateEvent = {
      id: `lpr-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      tenantId,
      ...event,
      timestamp: new Date(event.timestamp)
    };

    await analyticsEngine.processLicensePlateEvent(tenantId, lprEvent);

    return c.json({
      success: true,
      eventId: lprEvent.id,
      message: 'License plate event processed'
    });
  } catch (error) {
    analyticsLogger.error('License plate processing failed', { error });
    throw new HTTPException(500, { message: 'Failed to process license plate event' });
  }
});

// Process behavior analysis event
app.post('/analytics/video/behavior', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const body = await c.req.json();
    const event = BehaviorEventSchema.parse(body);

    const behaviorEvent: BehaviorEvent = {
      id: `behavior-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      tenantId,
      ...event,
      timestamp: new Date(event.timestamp)
    };

    await analyticsEngine.processBehaviorEvent(tenantId, behaviorEvent);

    return c.json({
      success: true,
      eventId: behaviorEvent.id,
      message: 'Behavior event processed'
    });
  } catch (error) {
    analyticsLogger.error('Behavior event processing failed', { error });
    throw new HTTPException(500, { message: 'Failed to process behavior event' });
  }
});

// Get face recognition events
app.get('/analytics/video/face-recognition', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const query = c.req.query();
    
    const searchQuery = {
      index: `face-recognition-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              ...(query.cameraId ? [{ term: { cameraId: query.cameraId } }] : []),
              ...(query.personId ? [{ term: { personId: query.personId } }] : []),
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [{ range: { timestamp: { gte: 'now-24h' } } }])
            ]
          }
        },
        sort: [{ timestamp: { order: 'desc' } }],
        size: parseInt(query.limit as string) || 100
      }
    };

    const response = await opensearch.search(searchQuery);
    const events = response.body.hits.hits.map((hit: any) => hit._source);

    return c.json({
      success: true,
      data: events,
      total: response.body.hits.total.value
    });
  } catch (error) {
    analyticsLogger.error('Face recognition query failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve face recognition events' });
  }
});

// Get license plate events
app.get('/analytics/video/license-plate', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const query = c.req.query();
    
    const searchQuery = {
      index: `license-plate-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              ...(query.cameraId ? [{ term: { cameraId: query.cameraId } }] : []),
              ...(query.plateNumber ? [{ term: { plateNumber: query.plateNumber } }] : []),
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [{ range: { timestamp: { gte: 'now-24h' } } }])
            ]
          }
        },
        sort: [{ timestamp: { order: 'desc' } }],
        size: parseInt(query.limit as string) || 100
      }
    };

    const response = await opensearch.search(searchQuery);
    const events = response.body.hits.hits.map((hit: any) => hit._source);

    return c.json({
      success: true,
      data: events,
      total: response.body.hits.total.value
    });
  } catch (error) {
    analyticsLogger.error('License plate query failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve license plate events' });
  }
});

// Get behavior events
app.get('/analytics/video/behavior', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const query = c.req.query();
    
    const searchQuery = {
      index: `behavior-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              ...(query.cameraId ? [{ term: { cameraId: query.cameraId } }] : []),
              ...(query.eventType ? [{ term: { eventType: query.eventType } }] : []),
              ...(query.severity ? [{ term: { severity: query.severity } }] : []),
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [{ range: { timestamp: { gte: 'now-24h' } } }])
            ]
          }
        },
        sort: [{ timestamp: { order: 'desc' } }],
        size: parseInt(query.limit as string) || 100
      }
    };

    const response = await opensearch.search(searchQuery);
    const events = response.body.hits.hits.map((hit: any) => hit._source);

    return c.json({
      success: true,
      data: events,
      total: response.body.hits.total.value
    });
  } catch (error) {
    analyticsLogger.error('Behavior events query failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve behavior events' });
  }
});

// Perform crowd analysis
app.post('/analytics/video/crowd-analysis', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const { cameraId } = await c.req.json();

    if (!cameraId) {
      throw new HTTPException(400, { message: 'Camera ID is required' });
    }

    const analysis = await analyticsEngine.performCrowdAnalysis(tenantId, cameraId);

    return c.json({
      success: true,
      data: analysis
    });
  } catch (error) {
    analyticsLogger.error('Crowd analysis failed', { error });
    throw new HTTPException(500, { message: 'Failed to perform crowd analysis' });
  }
});

// Enroll face
app.post('/analytics/video/face-enrollment', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const { personId, features, metadata } = await c.req.json();

    if (!personId || !features || !Array.isArray(features)) {
      throw new HTTPException(400, { message: 'Person ID and features array are required' });
    }

    await analyticsEngine.enrollFace(tenantId, personId, features, metadata);

    return c.json({
      success: true,
      message: 'Face enrolled successfully'
    });
  } catch (error) {
    analyticsLogger.error('Face enrollment failed', { error });
    throw new HTTPException(500, { message: 'Failed to enroll face' });
  }
});

// Update watchlists
app.post('/analytics/video/watchlist', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const { type, items } = await c.req.json();

    if (!type || !items || !Array.isArray(items)) {
      throw new HTTPException(400, { message: 'Type and items array are required' });
    }

    if (!['face', 'license_plate'].includes(type)) {
      throw new HTTPException(400, { message: 'Type must be "face" or "license_plate"' });
    }

    await analyticsEngine.updateWatchlists(tenantId, type, items);

    return c.json({
      success: true,
      message: `${type} watchlist updated successfully`
    });
  } catch (error) {
    analyticsLogger.error('Watchlist update failed', { error });
    throw new HTTPException(500, { message: 'Failed to update watchlist' });
  }
});

// Get incident predictions
app.get('/analytics/predictions', async (c) => {
  try {
    const tenantId = c.get('tenantId');

    const predictions = await analyticsEngine.generateIncidentPredictions(tenantId);

    return c.json({
      success: true,
      data: predictions
    });
  } catch (error) {
    analyticsLogger.error('Incident predictions failed', { error });
    throw new HTTPException(500, { message: 'Failed to generate incident predictions' });
  }
});

// Get person tracking data
app.get('/analytics/video/person-tracking/:personId', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const personId = c.req.param('personId');
    const query = c.req.query();

    const searchQuery = {
      index: `person-tracking-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              { term: { personId } },
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [{ range: { timestamp: { gte: 'now-24h' } } }])
            ]
          }
        },
        sort: [{ timestamp: { order: 'desc' } }],
        size: parseInt(query.limit as string) || 100
      }
    };

    const response = await opensearch.search(searchQuery);
    const tracking = response.body.hits.hits.map((hit: any) => hit._source);

    return c.json({
      success: true,
      data: tracking,
      total: response.body.hits.total.value
    });
  } catch (error) {
    analyticsLogger.error('Person tracking query failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve person tracking data' });
  }
});

// Get vehicle-access correlations
app.get('/analytics/video/vehicle-correlations', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const query = c.req.query();

    const searchQuery = {
      index: `vehicle-access-correlation-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              ...(query.plateNumber ? [{ term: { plateNumber: query.plateNumber } }] : []),
              ...(query.userId ? [{ term: { userId: query.userId } }] : []),
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [{ range: { timestamp: { gte: 'now-24h' } } }])
            ]
          }
        },
        sort: [{ timestamp: { order: 'desc' } }],
        size: parseInt(query.limit as string) || 100
      }
    };

    const response = await opensearch.search(searchQuery);
    const correlations = response.body.hits.hits.map((hit: any) => hit._source);

    return c.json({
      success: true,
      data: correlations,
      total: response.body.hits.total.value
    });
  } catch (error) {
    analyticsLogger.error('Vehicle correlation query failed', { error });
    throw new HTTPException(500, { message: 'Failed to retrieve vehicle correlations' });
  }
});

// Export analytics data
app.post('/analytics/export', async (c) => {
  try {
    const tenantId = c.get('tenantId');
    const body = await c.req.json();
    const { format = 'json', ...query } = body;

    const exportData = await opensearch.search({
      index: `access-events-${tenantId}`,
      body: {
        query: {
          bool: {
            must: [
              { term: { tenantId } },
              ...(query.startDate && query.endDate ? [{
                range: {
                  timestamp: {
                    gte: query.startDate,
                    lte: query.endDate
                  }
                }
              }] : [])
            ]
          }
        },
        size: query.limit || 10000,
        sort: [{ timestamp: { order: 'desc' } }]
      }
    });

    const data = exportData.body.hits.hits.map((hit: any) => hit._source);

    if (format === 'csv') {
      // Convert to CSV format
      const csv = this.convertToCSV(data);
      c.header('Content-Type', 'text/csv');
      c.header('Content-Disposition', 'attachment; filename=analytics-export.csv');
      return c.text(csv);
    }

    return c.json({
      success: true,
      data,
      total: exportData.body.hits.total.value,
      exported: data.length
    });
  } catch (error) {
    analyticsLogger.error('Analytics export failed', { error });
    throw new HTTPException(500, { message: 'Failed to export analytics data' });
  }
});

// Error handling
app.onError((err, c) => {
  analyticsLogger.error('Unhandled error', { error: err });
  
  if (err instanceof HTTPException) {
    return c.json({
      success: false,
      error: err.message
    }, err.status);
  }

  return c.json({
    success: false,
    error: 'Internal server error'
  }, 500);
});

// Background tasks
async function startBackgroundTasks() {
  // Generate predictive alerts every 15 minutes
  setInterval(async () => {
    try {
      const tenants = await prisma.tenant.findMany({ select: { id: true } });
      
      for (const tenant of tenants) {
        await analyticsEngine.generatePredictiveAlerts(tenant.id);
      }
      
      analyticsLogger.info('Predictive alerts generated for all tenants');
    } catch (error) {
      analyticsLogger.error('Background predictive alerts failed', { error });
    }
  }, 15 * 60 * 1000);

  // Update occupancy data every 5 minutes
  setInterval(async () => {
    try {
      const tenants = await prisma.tenant.findMany({ select: { id: true } });
      
      for (const tenant of tenants) {
        const occupancyData = await analyticsEngine.trackOccupancy(tenant.id);
        await redis.setex(`occupancy:${tenant.id}`, 300, JSON.stringify(occupancyData));
      }
      
      analyticsLogger.info('Occupancy data updated for all tenants');
    } catch (error) {
      analyticsLogger.error('Background occupancy update failed', { error });
    }
  }, 5 * 60 * 1000);

  // Generate incident predictions every 10 minutes
  setInterval(async () => {
    try {
      const tenants = await prisma.tenant.findMany({ select: { id: true } });
      
      for (const tenant of tenants) {
        await analyticsEngine.generateIncidentPredictions(tenant.id);
      }
      
      analyticsLogger.info('Incident predictions generated for all tenants');
    } catch (error) {
      analyticsLogger.error('Background incident predictions failed', { error });
    }
  }, 10 * 60 * 1000);

  // Perform crowd analysis every 2 minutes for active cameras
  setInterval(async () => {
    try {
      const tenants = await prisma.tenant.findMany({ select: { id: true } });
      
      for (const tenant of tenants) {
        // Get cameras with crowd analysis enabled
        const cameras = await prisma.camera.findMany({
          where: { 
            tenantId: tenant.id,
            status: 'online'
          },
          include: {
            videoAnalyticsConfig: true
          }
        });

        for (const camera of cameras) {
          if (camera.videoAnalyticsConfig?.behaviorAnalysis?.crowdAnalysis) {
            try {
              await analyticsEngine.performCrowdAnalysis(tenant.id, camera.id);
            } catch (error) {
              analyticsLogger.error('Crowd analysis failed for camera', { 
                error, 
                tenantId: tenant.id, 
                cameraId: camera.id 
              });
            }
          }
        }
      }
      
      analyticsLogger.info('Crowd analysis completed for all active cameras');
    } catch (error) {
      analyticsLogger.error('Background crowd analysis failed', { error });
    }
  }, 2 * 60 * 1000);

  // Clean up old analytics data every hour
  setInterval(async () => {
    try {
      const tenants = await prisma.tenant.findMany({ select: { id: true } });
      
      for (const tenant of tenants) {
        // Clean up old face recognition events (older than 90 days)
        await opensearch.deleteByQuery({
          index: `face-recognition-${tenant.id}`,
          body: {
            query: {
              range: {
                timestamp: {
                  lt: 'now-90d'
                }
              }
            }
          }
        });

        // Clean up old behavior events (older than 30 days)
        await opensearch.deleteByQuery({
          index: `behavior-events-${tenant.id}`,
          body: {
            query: {
              range: {
                timestamp: {
                  lt: 'now-30d'
                }
              }
            }
          }
        });

        // Clean up old predictions (older than 7 days)
        await opensearch.deleteByQuery({
          index: `incident-predictions-${tenant.id}`,
          body: {
            query: {
              range: {
                timestamp: {
                  lt: 'now-7d'
                }
              }
            }
          }
        });
      }
      
      analyticsLogger.info('Analytics data cleanup completed');
    } catch (error) {
      analyticsLogger.error('Background cleanup failed', { error });
    }
  }, 60 * 60 * 1000);
}

// WebSocket server for real-time analytics
const server = createServer();
const wss = new WebSocketServer({ server });

wss.on('connection', (ws, req) => {
  analyticsLogger.info('WebSocket connection established');
  
  ws.on('message', async (message) => {
    try {
      const data = JSON.parse(message.toString());
      
      if (data.type === 'subscribe' && data.tenantId) {
        // Subscribe to real-time analytics updates
        ws.tenantId = data.tenantId;
        ws.send(JSON.stringify({
          type: 'subscribed',
          tenantId: data.tenantId
        }));
      }
    } catch (error) {
      analyticsLogger.error('WebSocket message error', { error });
    }
  });

  ws.on('close', () => {
    analyticsLogger.info('WebSocket connection closed');
  });
});

// Start server
const port = parseInt(process.env.PORT || '3007');

server.on('request', app.fetch);

server.listen(port, () => {
  analyticsLogger.info(`Analytics service started on port ${port}`);
  startBackgroundTasks();
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  analyticsLogger.info('SIGTERM received, shutting down gracefully');
  
  await prisma.$disconnect();
  await redis.quit();
  
  server.close(() => {
    analyticsLogger.info('Analytics service stopped');
    process.exit(0);
  });
});

export default app;

// Test Suite - Only included in test environment
if (process.env.NODE_ENV === 'test') {
  
// Jest Test Configuration and Setup
const testConfig = {
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.test.ts',
    '!src/**/*.spec.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};

// Mock implementations for testing
const mockPrisma = {
  tenant: {
    findMany: jest.fn(),
    findFirst: jest.fn()
  },
  user: {
    findMany: jest.fn(),
    findFirst: jest.fn()
  },
  accessPanel: {
    findMany: jest.fn()
  },
  zone: {
    findFirst: jest.fn()
  },
  floor: {
    findFirst: jest.fn()
  },
  building: {
    findFirst: jest.fn()
  },
  $disconnect: jest.fn()
};

const mockRedis = {
  get: jest.fn(),
  set: jest.fn(),
  setex: jest.fn(),
  keys: jest.fn(),
  mget: jest.fn(),
  pipeline: jest.fn(() => ({
    setex: jest.fn(),
    exec: jest.fn()
  })),
  quit: jest.fn()
};

const mockOpenSearch = {
  search: jest.fn(),
  index: jest.fn()
};

const mockWebSocket = {
  send: jest.fn(),
  close: jest.fn(),
  on: jest.fn()
};

// Test Data Factories
const createMockAccessEvent = (overrides = {}) => ({
  id: 'event-123',
  tenantId: 'tenant-123',
  userId: 'user-123',
  doorId: 'door-123',
  buildingId: 'building-123',
  floorId: 'floor-123',
  zoneId: 'zone-123',
  timestamp: new Date().toISOString(),
  granted: true,
  eventType: 'entry',
  ...overrides
});

const createMockOccupancyData = (overrides = {}) => ({
  location: {
    buildingId: 'building-123',
    floorId: 'floor-123',
    zoneId: 'zone-123'
  },
  timestamp: new Date(),
  count: 10,
  capacity: 100,
  utilizationRate: 0.1,
  ...overrides
});

const createMockAnomalyScore = (overrides = {}) => ({
  entityId: 'user-123',
  entityType: 'user',
  score: 0.75,
  factors: ['Unusual high activity for current time'],
  timestamp: new Date(),
  severity: 'medium' as const,
  ...overrides
});

const createMockPredictiveAlert = (overrides = {}) => ({
  id: 'alert-123',
  type: 'potential_tailgating',
  severity: 'medium' as const,
  message: 'Potential tailgating detected',
  entityId: 'door-123',
  entityType: 'door',
  probability: 0.7,
  factors: ['Multiple rapid access attempts'],
  recommendedActions: ['Review video footage'],
  timestamp: new Date(),
  ...overrides
});

// Video Analytics Test Data Factories
const createMockFaceRecognitionEvent = (overrides = {}) => ({
  id: 'face-123',
  cameraId: 'camera-123',
  tenantId: 'tenant-123',
  timestamp: new Date(),
  personId: 'person-123',
  confidence: 0.85,
  boundingBox: { x: 100, y: 100, width: 50, height: 60 },
  features: Array(128).fill(0).map(() => Math.random()),
  isWatchlisted: false,
  metadata: {},
  ...overrides
});

const createMockLicensePlateEvent = (overrides = {}) => ({
  id: 'lpr-123',
  cameraId: 'camera-123',
  tenantId: 'tenant-123',
  timestamp: new Date(),
  plateNumber: 'ABC123',
  confidence: 0.9,
  region: 'US',
  boundingBox: { x: 200, y: 150, width: 100, height: 30 },
  vehicleType: 'sedan',
  isWatchlisted: false,
  metadata: {},
  ...overrides
});

const createMockBehaviorEvent = (overrides = {}) => ({
  id: 'behavior-123',
  cameraId: 'camera-123',
  tenantId: 'tenant-123',
  timestamp: new Date(),
  eventType: 'loitering' as const,
  severity: 'medium' as const,
  confidence: 0.8,
  location: { x: 0.5, y: 0.5 },
  duration: 300,
  objectCount: 1,
  metadata: {},
  ...overrides
});

const createMockVideoAnalyticsConfig = (overrides = {}) => ({
  cameraId: 'camera-123',
  faceRecognition: {
    enabled: true,
    confidence: 0.8,
    enrollmentMode: false,
    watchlistEnabled: true
  },
  licensePlateRecognition: {
    enabled: true,
    confidence: 0.85,
    regions: ['US', 'EU'],
    watchlistEnabled: true
  },
  behaviorAnalysis: {
    loiteringDetection: true,
    loiteringThreshold: 300,
    crowdAnalysis: true,
    crowdThreshold: 10,
    directionAnalysis: true,
    speedAnalysis: true
  },
  zones: [
    {
      id: 'zone-123',
      name: 'Entrance',
      coordinates: [
        { x: 0.1, y: 0.1 },
        { x: 0.9, y: 0.1 },
        { x: 0.9, y: 0.9 },
        { x: 0.1, y: 0.9 }
      ],
      type: 'detection' as const,
      analytics: ['face_recognition', 'behavior_analysis']
    }
  ],
  ...overrides
});

const createMockCrowdAnalysis = (overrides = {}) => ({
  cameraId: 'camera-123',
  timestamp: new Date(),
  totalCount: 15,
  density: 0.15,
  averageSpeed: 1.5,
  flowDirection: { angle: 45, magnitude: 0.7 },
  hotspots: [
    { x: 0.3, y: 0.4, intensity: 0.8 },
    { x: 0.7, y: 0.6, intensity: 0.6 }
  ],
  riskLevel: 'medium' as const,
  ...overrides
});

const createMockIncidentPrediction = (overrides = {}) => ({
  id: 'prediction-123',
  type: 'security_breach' as const,
  probability: 0.75,
  timeToIncident: 30,
  location: {
    buildingId: 'building-123',
    floorId: 'floor-123',
    zoneId: 'zone-123',
    cameraId: 'camera-123'
  },
  factors: ['Multiple failed access attempts', 'Unusual activity pattern'],
  recommendedActions: ['Increase security presence', 'Monitor area closely'],
  severity: 'high' as const,
  timestamp: new Date(),
  ...overrides
});

// Unit Tests for AnalyticsEngine Class
describe('AnalyticsEngine', () => {
  let analyticsEngine: AnalyticsEngine;
  
  beforeEach(() => {
    jest.clearAllMocks();
    analyticsEngine = new AnalyticsEngine();
    
    // Mock OpenSearch responses
    mockOpenSearch.search.mockResolvedValue({
      body: {
        hits: {
          hits: [
            { _source: createMockAccessEvent() }
          ],
          total: { value: 1 }
        },
        aggregations: {
          occupancy_over_time: {
            buckets: [
              {
                key: Date.now(),
                net_occupancy: { value: 5 },
                entries: { doc_count: 10 },
                exits: { doc_count: 5 }
              }
            ]
          }
        }
      }
    });
  });

  describe('detectAnomalies', () => {
    it('should detect anomalies correctly', async () => {
      const mockHistoricalData = Array(100).fill(null).map(() => createMockAccessEvent({
        timestamp: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString()
      }));
      
      const mockRecentData = Array(5).fill(null).map(() => createMockAccessEvent({
        timestamp: new Date(Date.now() - Math.random() * 24 * 60 * 60 * 1000).toISOString()
      }));

      mockOpenSearch.search
        .mockResolvedValueOnce({
          body: { hits: { hits: mockHistoricalData.map(data => ({ _source: data })) } }
        })
        .mockResolvedValueOnce({
          body: { hits: { hits: mockRecentData.map(data => ({ _source: data })) } }
        });

      const result = await analyticsEngine.detectAnomalies('tenant-123', 'user', 'user-123', 0.8);

      expect(result).toMatchObject({
        entityId: 'user-123',
        entityType: 'user',
        score: expect.any(Number),
        factors: expect.any(Array),
        severity: expect.stringMatching(/^(low|medium|high|critical)$/)
      });
      expect(mockOpenSearch.search).toHaveBeenCalledTimes(3); // Historical, recent, and store
      expect(mockOpenSearch.index).toHaveBeenCalledWith({
        index: 'anomalies-tenant-123',
        body: expect.objectContaining({
          entityId: 'user-123',
          tenantId: 'tenant-123'
        })
      });
    });

    it('should handle empty historical data', async () => {
      mockOpenSearch.search
        .mockResolvedValueOnce({ body: { hits: { hits: [] } } })
        .mockResolvedValueOnce({ body: { hits: { hits: [] } } });

      const result = await analyticsEngine.detectAnomalies('tenant-123', 'user', 'user-123');

      expect(result.score).toBe(0);
      expect(result.severity).toBe('low');
    });

    it('should throw error on OpenSearch failure', async () => {
      mockOpenSearch.search.mockRejectedValue(new Error('OpenSearch error'));

      await expect(analyticsEngine.detectAnomalies('tenant-123', 'user', 'user-123'))
        .rejects.toThrow('OpenSearch error');
    });
  });

  describe('trackOccupancy', () => {
    beforeEach(() => {
      mockPrisma.zone.findFirst.mockResolvedValue({ capacity: 50 });
      mockPrisma.floor.findFirst.mockResolvedValue({
        zones: [{ capacity: 50 }, { capacity: 30 }]
      });
      mockPrisma.building.findFirst.mockResolvedValue({
        floors: [
          { zones: [{ capacity: 50 }, { capacity: 30 }] },
          { zones: [{ capacity: 40 }] }
        ]
      });
    });

    it('should track occupancy for a zone', async () => {
      const result = await analyticsEngine.trackOccupancy('tenant-123', 'building-123', 'floor-123', 'zone-123');

      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        location: {
          buildingId: 'building-123',
          floorId: 'floor-123',
          zoneId: 'zone-123'
        },
        count: expect.any(Number),
        capacity: 50,
        utilizationRate: expect.any(Number)
      });
      expect(mockOpenSearch.search).toHaveBeenCalledWith(
        expect.objectContaining({
          index: 'access-events-tenant-123'
        })
      );
    });

    it('should track occupancy for a building', async () => {
      const result = await analyticsEngine.trackOccupancy('tenant-123', 'building-123');

      expect(result[0].capacity).toBe(120); // Sum of all zone capacities
      expect(mockPrisma.building.findFirst).toHaveBeenCalledWith({
        where: { id: 'building-123', tenantId: 'tenant-123' },
        include: { floors: { include: { zones: true } } }
      });
    });

    it('should handle database errors gracefully', async () => {
      mockPrisma.zone.findFirst.mockRejectedValue(new Error('Database error'));

      const result = await analyticsEngine.trackOccupancy('tenant-123', undefined, undefined, 'zone-123');

      expect(result[0].capacity).toBe(100); // Fallback capacity
    });
  });

  describe('generatePredictiveAlerts', () => {
    beforeEach(() => {
      mockPrisma.accessPanel.findMany.mockResolvedValue([
        { id: 'panel-123', doors: [{ id: 'door-123' }] }
      ]);
      mockPrisma.user.findMany.mockResolvedValue([
        { id: 'user-123', email: 'test@example.com' }
      ]);
    });

    it('should generate tailgating alerts', async () => {
      mockOpenSearch.search.mockResolvedValue({
        body: {
          aggregations: {
            doors: {
              buckets: [
                {
                  key: 'door-123',
                  rapid_access: { doc_count: 6 }
                }
              ]
            }
          }
        }
      });

      const result = await analyticsEngine.generatePredictiveAlerts('tenant-123');

      expect(result).toContainEqual(
        expect.objectContaining({
          type: 'potential_tailgating',
          entityId: 'door-123',
          severity: 'medium'
        })
      );
    });

    it('should generate capacity warnings', async () => {
      // Mock high occupancy data
      jest.spyOn(analyticsEngine, 'trackOccupancy').mockResolvedValue([
        createMockOccupancyData({ utilizationRate: 0.95 })
      ]);

      const result = await analyticsEngine.generatePredictiveAlerts('tenant-123');

      expect(result).toContainEqual(
        expect.objectContaining({
          type: 'capacity_warning',
          severity: 'high'
        })
      );
    });

    it('should generate device health alerts', async () => {
      mockOpenSearch.search.mockResolvedValue({
        body: { hits: { total: { value: 15 } } }
      });

      const result = await analyticsEngine.generatePredictiveAlerts('tenant-123');

      expect(result).toContainEqual(
        expect.objectContaining({
          type: 'device_degradation',
          entityId: 'panel-123',
          severity: 'medium'
        })
      );
    });

    it('should store alerts in Redis', async () => {
      const mockPipeline = {
        setex: jest.fn(),
        exec: jest.fn().mockResolvedValue([])
      };
      mockRedis.pipeline.mockReturnValue(mockPipeline);

      await analyticsEngine.generatePredictiveAlerts('tenant-123');

      expect(mockRedis.pipeline).toHaveBeenCalled();
      expect(mockPipeline.exec).toHaveBeenCalled();
    });
  });

  describe('Statistical Methods', () => {
    it('should calculate baseline patterns correctly', async () => {
      const mockData = Array(30).fill(null).map((_, i) => createMockAccessEvent({
        timestamp: new Date(Date.now() - i * 24 * 60 * 60 * 1000).toISOString()
      }));

      mockOpenSearch.search.mockResolvedValue({
        body: { hits: { hits: mockData.map(data => ({ _source: data })) } }
      });

      const baseline = await analyticsEngine['calculateBaseline'](mockData);

      expect(baseline).toHaveProperty('hourlyPatterns');
      expect(baseline).toHaveProperty('dailyPatterns');
      expect(baseline).toHaveProperty('locationPatterns');
      expect(baseline).toHaveProperty('totalEvents', 30);
      expect(baseline).toHaveProperty('avgEventsPerDay', 1);
    });

    it('should calculate anomaly scores accurately', async () => {
      const baseline = {
        hourlyPatterns: new Map([[9, { mean: 5, std: 2, count: 10 }]]),
        dailyPatterns: new Map([[1, { mean: 10, std: 3, count: 5 }]]),
        locationPatterns: new Map([['building-123-floor-123-zone-123', 20]]),
        avgEventsPerDay: 10
      };

      const recentActivity = Array(15).fill(null).map(() => createMockAccessEvent({
        timestamp: new Date().toISOString()
      }));

      const score = await analyticsEngine['calculateAnomalyScore'](baseline, recentActivity);

      expect(score).toBeGreaterThanOrEqual(0);
      expect(score).toBeLessThanOrEqual(1);
    });

    it('should determine severity levels correctly', () => {
      expect(analyticsEngine['determineSeverity'](0.3, 0.8)).toBe('low');
      expect(analyticsEngine['determineSeverity'](0.6, 0.8)).toBe('medium');
      expect(analyticsEngine['determineSeverity'](0.9, 0.8)).toBe('high');
      expect(analyticsEngine['determineSeverity'](1.5, 0.8)).toBe('critical');
    });
  });
});

// Unit Tests for API Endpoints
describe('Analytics API Endpoints', () => {
  let testApp: any;

  beforeEach(() => {
    jest.clearAllMocks();
    testApp = app;
  });

  describe('GET /analytics/security', () => {
    it('should return security analytics data', async () => {
      const mockRequest = {
        header: jest.fn().mockReturnValue('Bearer valid-token'),
        query: jest.fn().mockReturnValue({
          tenantId: 'tenant-123',
          startDate: '2024-01-01T00:00:00Z',
          endDate: '2024-01-31T23:59:59Z'
        })
      };

      const mockContext = {
        req: mockRequest,
        get: jest.fn().mockReturnValue('tenant-123'),
        json: jest.fn()
      };

      mockOpenSearch.search.mockResolvedValue({
        body: {
          hits: { total: { value: 100 } },
          aggregations: {
            access_attempts: { buckets: [{ key: true, doc_count: 80 }] },
            hourly_distribution: { buckets: [] },
            top_doors: { buckets: [] },
            failed_attempts: { by_user: { buckets: [] } }
          }
        }
      });

      // Simulate endpoint execution
      const response = await testApp.request('/analytics/security', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(200);
    });

    it('should handle invalid query parameters', async () => {
      const response = await testApp.request('/analytics/security?tenantId=invalid-uuid', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(400);
    });

    it('should require authentication', async () => {
      const response = await testApp.request('/analytics/security');

      expect(response.status).toBe(401);
    });
  });

  describe('GET /analytics/occupancy', () => {
    it('should return occupancy data', async () => {
      jest.spyOn(analyticsEngine, 'trackOccupancy').mockResolvedValue([
        createMockOccupancyData()
      ]);

      const response = await testApp.request('/analytics/occupancy?tenantId=tenant-123', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveLength(1);
    });
  });

  describe('POST /analytics/anomalies', () => {
    it('should detect anomalies', async () => {
      jest.spyOn(analyticsEngine, 'detectAnomalies').mockResolvedValue(
        createMockAnomalyScore()
      );

      const response = await testApp.request('/analytics/anomalies', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          tenantId: 'tenant-123',
          entityType: 'user',
          entityId: 'user-123',
          threshold: 0.8
        })
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data.entityId).toBe('user-123');
    });

    it('should validate request body', async () => {
      const response = await testApp.request('/analytics/anomalies', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          entityType: 'invalid-type'
        })
      });

      expect(response.status).toBe(400);
    });
  });

  describe('GET /analytics/dashboard', () => {
    it('should return cached dashboard data', async () => {
      const cachedData = {
        timestamp: new Date().toISOString(),
        security: { totalEvents: 100 },
        occupancy: [],
        alerts: []
      };

      mockRedis.get.mockResolvedValue(JSON.stringify(cachedData));

      const response = await testApp.request('/analytics/dashboard', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.cached).toBe(true);
    });

    it('should generate fresh dashboard data when cache miss', async () => {
      mockRedis.get.mockResolvedValue(null);
      mockRedis.keys.mockResolvedValue(['alert:tenant-123:alert-1']);
      mockRedis.mget.mockResolvedValue([JSON.stringify(createMockPredictiveAlert())]);

      jest.spyOn(analyticsEngine, 'trackOccupancy').mockResolvedValue([]);

      const response = await testApp.request('/analytics/dashboard', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.cached).toBe(false);
      expect(mockRedis.setex).toHaveBeenCalled();
    });
  });
});

// Integration Tests
describe('Analytics Service Integration', () => {
  describe('End-to-End Workflows', () => {
    it('should complete full anomaly detection workflow', async () => {
      // Setup test data
      const tenantId = 'tenant-123';
      const userId = 'user-123';

      // Mock database responses
      mockPrisma.user.findMany.mockResolvedValue([
        { id: userId, email: 'test@example.com', tenantId }
      ]);

      // Mock OpenSearch responses for historical and recent data
      mockOpenSearch.search
        .mockResolvedValueOnce({
          body: {
            hits: {
              hits: Array(50).fill(null).map(() => ({
                _source: createMockAccessEvent({ userId, tenantId })
              }))
            }
          }
        })
        .mockResolvedValueOnce({
          body: {
            hits: {
              hits: Array(10).fill(null).map(() => ({
                _source: createMockAccessEvent({ userId, tenantId })
              }))
            }
          }
        });

      // Execute anomaly detection
      const anomaly = await analyticsEngine.detectAnomalies(tenantId, 'user', userId);

      // Verify results
      expect(anomaly).toMatchObject({
        entityId: userId,
        entityType: 'user',
        score: expect.any(Number),
        factors: expect.any(Array),
        severity: expect.stringMatching(/^(low|medium|high|critical)$/)
      });

      // Verify data was stored
      expect(mockOpenSearch.index).toHaveBeenCalledWith({
        index: `anomalies-${tenantId}`,
        body: expect.objectContaining({
          entityId: userId,
          tenantId
        })
      });
    });

    it('should complete predictive alert generation workflow', async () => {
      const tenantId = 'tenant-123';

      // Mock all required data
      mockPrisma.accessPanel.findMany.mockResolvedValue([
        { id: 'panel-123', doors: [{ id: 'door-123' }] }
      ]);
      mockPrisma.user.findMany.mockResolvedValue([
        { id: 'user-123', email: 'test@example.com' }
      ]);

      // Mock OpenSearch responses for different alert types
      mockOpenSearch.search
        .mockResolvedValueOnce({
          body: {
            aggregations: {
              doors: {
                buckets: [{ key: 'door-123', rapid_access: { doc_count: 6 } }]
              }
            }
          }
        })
        .mockResolvedValueOnce({
          body: { hits: { total: { value: 15 } } }
        });

      // Mock occupancy tracking
      jest.spyOn(analyticsEngine, 'trackOccupancy').mockResolvedValue([
        createMockOccupancyData({ utilizationRate: 0.95 })
      ]);

      // Mock Redis pipeline
      const mockPipeline = {
        setex: jest.fn(),
        exec: jest.fn().mockResolvedValue([])
      };
      mockRedis.pipeline.mockReturnValue(mockPipeline);

      // Execute predictive alert generation
      const alerts = await analyticsEngine.generatePredictiveAlerts(tenantId);

      // Verify alerts were generated
      expect(alerts.length).toBeGreaterThan(0);
      expect(alerts).toContainEqual(
        expect.objectContaining({
          type: 'potential_tailgating',
          entityId: 'door-123'
        })
      );
      expect(alerts).toContainEqual(
        expect.objectContaining({
          type: 'capacity_warning'
        })
      );

      // Verify alerts were stored in Redis
      expect(mockRedis.pipeline).toHaveBeenCalled();
      expect(mockPipeline.exec).toHaveBeenCalled();
    });
  });

  describe('Real-time Data Processing', () => {
    it('should handle high-volume event processing', async () => {
      const tenantId = 'tenant-123';
      const eventCount = 10000;

      // Mock large dataset
      const mockEvents = Array(eventCount).fill(null).map((_, i) => ({
        _source: createMockAccessEvent({
          id: `event-${i}`,
          tenantId,
          timestamp: new Date(Date.now() - i * 1000).toISOString()
        })
      }));

      mockOpenSearch.search.mockResolvedValue({
        body: {
          hits: {
            hits: mockEvents,
            total: { value: eventCount }
          },
          aggregations: {
            access_attempts: { buckets: [] },
            hourly_distribution: { buckets: [] },
            top_doors: { buckets: [] },
            failed_attempts: { by_user: { buckets: [] } }
          }
        }
      });

      const startTime = Date.now();
      
      // Execute security analytics on large dataset
      const response = await testApp.request('/analytics/security', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      const endTime = Date.now();
      const processingTime = endTime - startTime;

      expect(response.status).toBe(200);
      expect(processingTime).toBeLessThan(5000); // Should complete within 5 seconds
    });

    it('should handle concurrent requests efficiently', async () => {
      const tenantId = 'tenant-123';
      const concurrentRequests = 10;

      // Mock responses
      mockOpenSearch.search.mockResolvedValue({
        body: {
          hits: { total: { value: 100 } },
          aggregations: {
            access_attempts: { buckets: [] },
            hourly_distribution: { buckets: [] },
            top_doors: { buckets: [] },
            failed_attempts: { by_user: { buckets: [] } }
          }
        }
      });

      // Execute concurrent requests
      const requests = Array(concurrentRequests).fill(null).map(() =>
        testApp.request('/analytics/security', {
          headers: { 'Authorization': 'Bearer valid-token' }
        })
      );

      const responses = await Promise.all(requests);

      // Verify all requests succeeded
      responses.forEach(response => {
        expect(response.status).toBe(200);
      });
    });
  });

  describe('Error Handling and Resilience', () => {
    it('should handle OpenSearch connection failures', async () => {
      mockOpenSearch.search.mockRejectedValue(new Error('Connection refused'));

      const response = await testApp.request('/analytics/security', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(500);
      const data = await response.json();
      expect(data.success).toBe(false);
      expect(data.error).toContain('Failed to retrieve security analytics');
    });

    it('should handle Redis connection failures gracefully', async () => {
      mockRedis.get.mockRejectedValue(new Error('Redis connection failed'));
      
      // Should still work without cache
      mockOpenSearch.search.mockResolvedValue({
        body: {
          hits: { total: { value: 0 } },
          aggregations: {
            total_events: { value: 0 },
            success_rate: { buckets: [] },
            active_doors: { value: 0 },
            unique_users: { value: 0 }
          }
        }
      });

      jest.spyOn(analyticsEngine, 'trackOccupancy').mockResolvedValue([]);
      mockRedis.keys.mockResolvedValue([]);

      const response = await testApp.request('/analytics/dashboard', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(200);
    });

    it('should handle database connection failures', async () => {
      mockPrisma.zone.findFirst.mockRejectedValue(new Error('Database connection failed'));

      // Should use fallback capacity
      const result = await analyticsEngine.trackOccupancy('tenant-123', undefined, undefined, 'zone-123');

      expect(result[0].capacity).toBe(100); // Fallback capacity
    });
  });
});

// Performance Tests
describe('Analytics Performance Tests', () => {
  describe('Anomaly Detection Performance', () => {
    it('should process large datasets efficiently', async () => {
      const largeDataset = Array(10000).fill(null).map(() => createMockAccessEvent());

      mockOpenSearch.search
        .mockResolvedValueOnce({
          body: { hits: { hits: largeDataset.map(data => ({ _source: data })) } }
        })
        .mockResolvedValueOnce({
          body: { hits: { hits: largeDataset.slice(0, 1000).map(data => ({ _source: data })) } }
        });

      const startTime = Date.now();
      await analyticsEngine.detectAnomalies('tenant-123', 'user', 'user-123');
      const endTime = Date.now();

      expect(endTime - startTime).toBeLessThan(2000); // Should complete within 2 seconds
    });

    it('should handle memory efficiently with large datasets', async () => {
      const initialMemory = process.memoryUsage().heapUsed;

      // Process multiple large datasets
      for (let i = 0; i < 5; i++) {
        const largeDataset = Array(5000).fill(null).map(() => createMockAccessEvent());
        
        mockOpenSearch.search
          .mockResolvedValueOnce({
            body: { hits: { hits: largeDataset.map(data => ({ _source: data })) } }
          })
          .mockResolvedValueOnce({
            body: { hits: { hits: largeDataset.slice(0, 500).map(data => ({ _source: data })) } }
          });

        await analyticsEngine.detectAnomalies('tenant-123', 'user', `user-${i}`);
      }

      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = finalMemory - initialMemory;

      // Memory increase should be reasonable (less than 100MB)
      expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024);
    });
  });

  describe('Real-time Analytics Performance', () => {
    it('should maintain low latency for dashboard updates', async () => {
      mockRedis.get.mockResolvedValue(null);
      mockRedis.keys.mockResolvedValue([]);
      mockOpenSearch.search.mockResolvedValue({
        body: {
          hits: { total: { value: 1000 } },
          aggregations: {
            total_events: { value: 1000 },
            success_rate: { buckets: [] },
            active_doors: { value: 50 },
            unique_users: { value: 200 }
          }
        }
      });

      jest.spyOn(analyticsEngine, 'trackOccupancy').mockResolvedValue([]);

      const startTime = Date.now();
      
      const response = await testApp.request('/analytics/dashboard', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      const endTime = Date.now();
      const responseTime = endTime - startTime;

      expect(response.status).toBe(200);
      expect(responseTime).toBeLessThan(1000); // Should respond within 1 second
    });
  });
});

// WebSocket Tests
describe('WebSocket Real-time Analytics', () => {
  let mockWs: any;

  beforeEach(() => {
    mockWs = {
      send: jest.fn(),
      on: jest.fn(),
      tenantId: undefined
    };
  });

  it('should handle WebSocket subscription', () => {
    const messageHandler = jest.fn();
    mockWs.on.mockImplementation((event: string, handler: Function) => {
      if (event === 'message') {
        messageHandler.mockImplementation(handler);
      }
    });

    // Simulate WebSocket connection
    const subscriptionMessage = JSON.stringify({
      type: 'subscribe',
      tenantId: 'tenant-123'
    });

    messageHandler(Buffer.from(subscriptionMessage));

    expect(mockWs.tenantId).toBe('tenant-123');
    expect(mockWs.send).toHaveBeenCalledWith(
      JSON.stringify({
        type: 'subscribed',
        tenantId: 'tenant-123'
      })
    );
  });

  it('should handle invalid WebSocket messages', () => {
    const messageHandler = jest.fn();
    mockWs.on.mockImplementation((event: string, handler: Function) => {
      if (event === 'message') {
        messageHandler.mockImplementation(handler);
      }
    });

    // Simulate invalid message
    messageHandler(Buffer.from('invalid json'));

    // Should not crash and should not set tenantId
    expect(mockWs.tenantId).toBeUndefined();
  });
});

// Background Task Tests
describe('Background Tasks', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should generate predictive alerts on schedule', async () => {
    mockPrisma.tenant.findMany.mockResolvedValue([
      { id: 'tenant-1' },
      { id: 'tenant-2' }
    ]);

    jest.spyOn(analyticsEngine, 'generatePredictiveAlerts').mockResolvedValue([]);

    // Start background tasks
    startBackgroundTasks();

    // Fast-forward 15 minutes
    jest.advanceTimersByTime(15 * 60 * 1000);

    await Promise.resolve(); // Allow async operations to complete

    expect(analyticsEngine.generatePredictiveAlerts).toHaveBeenCalledWith('tenant-1');
    expect(analyticsEngine.generatePredictiveAlerts).toHaveBeenCalledWith('tenant-2');
  });

  it('should update occupancy data on schedule', async () => {
    mockPrisma.tenant.findMany.mockResolvedValue([{ id: 'tenant-1' }]);
    jest.spyOn(analyticsEngine, 'trackOccupancy').mockResolvedValue([]);

    // Start background tasks
    startBackgroundTasks();

    // Fast-forward 5 minutes
    jest.advanceTimersByTime(5 * 60 * 1000);

    await Promise.resolve();

    expect(analyticsEngine.trackOccupancy).toHaveBeenCalledWith('tenant-1');
    expect(mockRedis.setex).toHaveBeenCalledWith(
      'occupancy:tenant-1',
      300,
      expect.any(String)
    );
  });
});

// Video Analytics Tests
describe('Video Analytics Engine', () => {
  let analyticsEngine: AnalyticsEngine;
  
  beforeEach(() => {
    jest.clearAllMocks();
    analyticsEngine = new AnalyticsEngine();
  });

  describe('configureVideoAnalytics', () => {
    it('should configure video analytics for a camera', async () => {
      const config = createMockVideoAnalyticsConfig();
      
      mockPrisma.camera.findFirst.mockResolvedValue({
        id: config.cameraId,
        tenantId: 'tenant-123'
      });
      
      mockPrisma.videoAnalyticsConfig.upsert.mockResolvedValue(config);

      await analyticsEngine.configureVideoAnalytics('tenant-123', config);

      expect(mockPrisma.videoAnalyticsConfig.upsert).toHaveBeenCalledWith({
        where: { cameraId: config.cameraId },
        update: expect.objectContaining({
          faceRecognition: config.faceRecognition,
          licensePlateRecognition: config.licensePlateRecognition,
          behaviorAnalysis: config.behaviorAnalysis
        }),
        create: expect.objectContaining({
          cameraId: config.cameraId,
          tenantId: 'tenant-123'
        })
      });
    });

    it('should throw error for non-existent camera', async () => {
      const config = createMockVideoAnalyticsConfig();
      mockPrisma.camera.findFirst.mockResolvedValue(null);

      await expect(analyticsEngine.configureVideoAnalytics('tenant-123', config))
        .rejects.toThrow('Camera not found or access denied');
    });
  });

  describe('processFaceRecognitionEvent', () => {
    it('should process face recognition event with matching', async () => {
      const event = createMockFaceRecognitionEvent();
      const config = createMockVideoAnalyticsConfig();
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);
      analyticsEngine['faceDatabase'].set('tenant-123:person-123', {
        personId: 'person-123',
        features: event.features!,
        metadata: {}
      });

      await analyticsEngine.processFaceRecognitionEvent('tenant-123', event);

      expect(mockOpenSearch.index).toHaveBeenCalledWith({
        index: 'face-recognition-tenant-123',
        body: expect.objectContaining({
          cameraId: event.cameraId,
          personId: event.personId,
          tenantId: 'tenant-123'
        })
      });
    });

    it('should skip processing if face recognition disabled', async () => {
      const event = createMockFaceRecognitionEvent();
      const config = createMockVideoAnalyticsConfig({
        faceRecognition: { ...createMockVideoAnalyticsConfig().faceRecognition, enabled: false }
      });
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);

      await analyticsEngine.processFaceRecognitionEvent('tenant-123', event);

      expect(mockOpenSearch.index).not.toHaveBeenCalled();
    });

    it('should generate alert for watchlisted person', async () => {
      const event = createMockFaceRecognitionEvent({ isWatchlisted: true });
      const config = createMockVideoAnalyticsConfig();
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);

      await analyticsEngine.processFaceRecognitionEvent('tenant-123', event);

      expect(mockRedis.setex).toHaveBeenCalledWith(
        expect.stringMatching(/alert:tenant-123:face-alert/),
        3600,
        expect.any(String)
      );
    });
  });

  describe('processLicensePlateEvent', () => {
    it('should process license plate event', async () => {
      const event = createMockLicensePlateEvent();
      const config = createMockVideoAnalyticsConfig();
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);

      await analyticsEngine.processLicensePlateEvent('tenant-123', event);

      expect(mockOpenSearch.index).toHaveBeenCalledWith({
        index: 'license-plate-tenant-123',
        body: expect.objectContaining({
          cameraId: event.cameraId,
          plateNumber: event.plateNumber,
          tenantId: 'tenant-123'
        })
      });
    });

    it('should generate alert for watchlisted plate', async () => {
      const event = createMockLicensePlateEvent({ plateNumber: 'WANTED123' });
      const config = createMockVideoAnalyticsConfig();
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);
      analyticsEngine['licensePlateWatchlist'].add('WANTED123');

      await analyticsEngine.processLicensePlateEvent('tenant-123', event);

      expect(mockRedis.setex).toHaveBeenCalledWith(
        expect.stringMatching(/alert:tenant-123:lpr-alert/),
        3600,
        expect.any(String)
      );
    });
  });

  describe('processBehaviorEvent', () => {
    it('should process behavior event', async () => {
      const event = createMockBehaviorEvent();
      const config = createMockVideoAnalyticsConfig();
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);

      await analyticsEngine.processBehaviorEvent('tenant-123', event);

      expect(mockOpenSearch.index).toHaveBeenCalledWith({
        index: 'behavior-events-tenant-123',
        body: expect.objectContaining({
          cameraId: event.cameraId,
          eventType: event.eventType,
          tenantId: 'tenant-123'
        })
      });
    });

    it('should generate alert for high severity events', async () => {
      const event = createMockBehaviorEvent({ severity: 'high' });
      const config = createMockVideoAnalyticsConfig();
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);

      await analyticsEngine.processBehaviorEvent('tenant-123', event);

      expect(mockRedis.setex).toHaveBeenCalledWith(
        expect.stringMatching(/alert:tenant-123:behavior-alert/),
        3600,
        expect.any(String)
      );
    });

    it('should skip disabled behavior analysis types', async () => {
      const event = createMockBehaviorEvent({ eventType: 'crowd_formation' });
      const config = createMockVideoAnalyticsConfig({
        behaviorAnalysis: { 
          ...createMockVideoAnalyticsConfig().behaviorAnalysis, 
          crowdAnalysis: false 
        }
      });
      
      analyticsEngine['videoAnalyticsConfigs'].set(event.cameraId, config);

      await analyticsEngine.processBehaviorEvent('tenant-123', event);

      expect(mockOpenSearch.index).not.toHaveBeenCalled();
    });
  });

  describe('performCrowdAnalysis', () => {
    it('should perform crowd analysis', async () => {
      const cameraId = 'camera-123';
      const config = createMockVideoAnalyticsConfig();
      
      analyticsEngine['videoAnalyticsConfigs'].set(cameraId, config);
      
      // Mock recent person detections
      mockOpenSearch.search.mockResolvedValue({
        body: {
          hits: {
            hits: Array(15).fill(null).map(() => ({
              _source: createMockFaceRecognitionEvent({ cameraId })
            }))
          }
        }
      });

      const analysis = await analyticsEngine.performCrowdAnalysis('tenant-123', cameraId);

      expect(analysis).toMatchObject({
        cameraId,
        totalCount: 15,
        density: expect.any(Number),
        averageSpeed: expect.any(Number),
        flowDirection: expect.objectContaining({
          angle: expect.any(Number),
          magnitude: expect.any(Number)
        }),
        hotspots: expect.any(Array),
        riskLevel: expect.stringMatching(/^(low|medium|high|critical)$/)
      });

      expect(mockOpenSearch.index).toHaveBeenCalledWith({
        index: 'crowd-analysis-tenant-123',
        body: expect.objectContaining({
          cameraId,
          tenantId: 'tenant-123'
        })
      });
    });

    it('should throw error if crowd analysis not enabled', async () => {
      const cameraId = 'camera-123';
      const config = createMockVideoAnalyticsConfig({
        behaviorAnalysis: { 
          ...createMockVideoAnalyticsConfig().behaviorAnalysis, 
          crowdAnalysis: false 
        }
      });
      
      analyticsEngine['videoAnalyticsConfigs'].set(cameraId, config);

      await expect(analyticsEngine.performCrowdAnalysis('tenant-123', cameraId))
        .rejects.toThrow('Crowd analysis not enabled for this camera');
    });
  });

  describe('generateIncidentPredictions', () => {
    it('should generate incident predictions', async () => {
      // Mock various data sources for predictions
      mockOpenSearch.search
        .mockResolvedValueOnce({
          body: {
            aggregations: {
              by_door: {
                buckets: [{ key: 'door-123', doc_count: 8 }]
              },
              by_user: {
                buckets: [{ key: 'user-123', doc_count: 5 }]
              }
            }
          }
        })
        .mockResolvedValueOnce({
          body: {
            hits: {
              hits: [
                { _source: createMockCrowdAnalysis({ riskLevel: 'high' }) }
              ]
            }
          }
        })
        .mockResolvedValueOnce({
          body: {
            aggregations: {
              by_device: {
                buckets: [{ key: 'device-123', doc_count: 12 }]
              }
            }
          }
        })
        .mockResolvedValueOnce({
          body: {
            aggregations: {
              by_camera: {
                buckets: [{ key: 'camera-123', doc_count: 4 }]
              }
            }
          }
        });

      const predictions = await analyticsEngine.generateIncidentPredictions('tenant-123');

      expect(predictions.length).toBeGreaterThan(0);
      expect(predictions[0]).toMatchObject({
        id: expect.any(String),
        type: expect.stringMatching(/^(security_breach|crowd_incident|equipment_failure|safety_violation)$/),
        probability: expect.any(Number),
        timeToIncident: expect.any(Number),
        location: expect.any(Object),
        factors: expect.any(Array),
        recommendedActions: expect.any(Array),
        severity: expect.stringMatching(/^(low|medium|high|critical)$/),
        timestamp: expect.any(Date)
      });

      expect(mockOpenSearch.index).toHaveBeenCalledWith(
        expect.objectContaining({
          index: 'incident-predictions-tenant-123'
        })
      );
    });
  });

  describe('enrollFace', () => {
    it('should enroll face successfully', async () => {
      const personId = 'person-123';
      const features = Array(128).fill(0).map(() => Math.random());
      const metadata = { name: 'John Doe', department: 'Security' };

      mockPrisma.faceEnrollment.create.mockResolvedValue({
        personId,
        tenantId: 'tenant-123',
        features,
        metadata
      });

      await analyticsEngine.enrollFace('tenant-123', personId, features, metadata);

      expect(mockPrisma.faceEnrollment.create).toHaveBeenCalledWith({
        data: {
          personId,
          tenantId: 'tenant-123',
          features,
          metadata,
          enrolledAt: expect.any(Date)
        }
      });

      expect(analyticsEngine['faceDatabase'].has('tenant-123:person-123')).toBe(true);
    });
  });

  describe('updateWatchlists', () => {
    it('should update face watchlist', async () => {
      const faceIds = ['person-1', 'person-2', 'person-3'];

      mockPrisma.faceWatchlist.deleteMany.mockResolvedValue({ count: 0 });
      mockPrisma.faceWatchlist.createMany.mockResolvedValue({ count: 3 });

      await analyticsEngine.updateWatchlists('tenant-123', 'face', faceIds);

      expect(mockPrisma.faceWatchlist.deleteMany).toHaveBeenCalledWith({
        where: { tenantId: 'tenant-123' }
      });
      expect(mockPrisma.faceWatchlist.createMany).toHaveBeenCalledWith({
        data: faceIds.map(personId => ({ tenantId: 'tenant-123', personId }))
      });

      faceIds.forEach(id => {
        expect(analyticsEngine['faceWatchlist'].has(id)).toBe(true);
      });
    });

    it('should update license plate watchlist', async () => {
      const plates = ['ABC123', 'XYZ789', 'DEF456'];

      mockPrisma.licensePlateWatchlist.deleteMany.mockResolvedValue({ count: 0 });
      mockPrisma.licensePlateWatchlist.createMany.mockResolvedValue({ count: 3 });

      await analyticsEngine.updateWatchlists('tenant-123', 'license_plate', plates);

      expect(mockPrisma.licensePlateWatchlist.deleteMany).toHaveBeenCalledWith({
        where: { tenantId: 'tenant-123' }
      });
      expect(mockPrisma.licensePlateWatchlist.createMany).toHaveBeenCalledWith({
        data: plates.map(plateNumber => ({ tenantId: 'tenant-123', plateNumber }))
      });

      plates.forEach(plate => {
        expect(analyticsEngine['licensePlateWatchlist'].has(plate)).toBe(true);
      });
    });
  });

  describe('Face Matching', () => {
    it('should match faces with high similarity', async () => {
      const features1 = Array(128).fill(0).map(() => Math.random());
      const features2 = [...features1]; // Identical features
      
      analyticsEngine['faceDatabase'].set('tenant-123:person-123', {
        personId: 'person-123',
        features: features1,
        metadata: {}
      });

      const match = await analyticsEngine['matchFace'](features2, 0.8);

      expect(match).toMatchObject({
        personId: 'person-123',
        similarity: expect.any(Number)
      });
      expect(match!.similarity).toBeGreaterThan(0.8);
    });

    it('should not match faces with low similarity', async () => {
      const features1 = Array(128).fill(0).map(() => Math.random());
      const features2 = Array(128).fill(0).map(() => Math.random());
      
      analyticsEngine['faceDatabase'].set('tenant-123:person-123', {
        personId: 'person-123',
        features: features1,
        metadata: {}
      });

      const match = await analyticsEngine['matchFace'](features2, 0.9);

      expect(match).toBeNull();
    });
  });
});

// Video Analytics API Tests
describe('Video Analytics API Endpoints', () => {
  let testApp: any;

  beforeEach(() => {
    jest.clearAllMocks();
    testApp = app;
  });

  describe('POST /analytics/video/configure', () => {
    it('should configure video analytics', async () => {
      const config = createMockVideoAnalyticsConfig();
      
      jest.spyOn(analyticsEngine, 'configureVideoAnalytics').mockResolvedValue();

      const response = await testApp.request('/analytics/video/configure', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(config)
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(analyticsEngine.configureVideoAnalytics).toHaveBeenCalledWith('tenant-123', config);
    });

    it('should validate configuration schema', async () => {
      const invalidConfig = { cameraId: 'invalid-uuid' };

      const response = await testApp.request('/analytics/video/configure', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(invalidConfig)
      });

      expect(response.status).toBe(400);
    });
  });

  describe('POST /analytics/video/face-recognition', () => {
    it('should process face recognition event', async () => {
      const event = {
        cameraId: 'camera-123',
        timestamp: new Date().toISOString(),
        confidence: 0.85,
        boundingBox: { x: 100, y: 100, width: 50, height: 60 }
      };

      jest.spyOn(analyticsEngine, 'processFaceRecognitionEvent').mockResolvedValue();

      const response = await testApp.request('/analytics/video/face-recognition', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(event)
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.eventId).toBeDefined();
    });
  });

  describe('POST /analytics/video/license-plate', () => {
    it('should process license plate event', async () => {
      const event = {
        cameraId: 'camera-123',
        timestamp: new Date().toISOString(),
        plateNumber: 'ABC123',
        confidence: 0.9,
        region: 'US',
        boundingBox: { x: 200, y: 150, width: 100, height: 30 }
      };

      jest.spyOn(analyticsEngine, 'processLicensePlateEvent').mockResolvedValue();

      const response = await testApp.request('/analytics/video/license-plate', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(event)
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.eventId).toBeDefined();
    });
  });

  describe('POST /analytics/video/behavior', () => {
    it('should process behavior event', async () => {
      const event = {
        cameraId: 'camera-123',
        timestamp: new Date().toISOString(),
        eventType: 'loitering',
        severity: 'medium',
        confidence: 0.8,
        location: { x: 0.5, y: 0.5 }
      };

      jest.spyOn(analyticsEngine, 'processBehaviorEvent').mockResolvedValue();

      const response = await testApp.request('/analytics/video/behavior', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(event)
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.eventId).toBeDefined();
    });
  });

  describe('GET /analytics/video/face-recognition', () => {
    it('should retrieve face recognition events', async () => {
      const mockEvents = [createMockFaceRecognitionEvent()];
      
      mockOpenSearch.search.mockResolvedValue({
        body: {
          hits: {
            hits: mockEvents.map(event => ({ _source: event })),
            total: { value: 1 }
          }
        }
      });

      const response = await testApp.request('/analytics/video/face-recognition', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveLength(1);
      expect(data.total).toBe(1);
    });
  });

  describe('POST /analytics/video/crowd-analysis', () => {
    it('should perform crowd analysis', async () => {
      const mockAnalysis = createMockCrowdAnalysis();
      
      jest.spyOn(analyticsEngine, 'performCrowdAnalysis').mockResolvedValue(mockAnalysis);

      const response = await testApp.request('/analytics/video/crowd-analysis', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ cameraId: 'camera-123' })
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toMatchObject(mockAnalysis);
    });

    it('should require camera ID', async () => {
      const response = await testApp.request('/analytics/video/crowd-analysis', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
      });

      expect(response.status).toBe(400);
    });
  });

  describe('POST /analytics/video/face-enrollment', () => {
    it('should enroll face', async () => {
      const enrollmentData = {
        personId: 'person-123',
        features: Array(128).fill(0).map(() => Math.random()),
        metadata: { name: 'John Doe' }
      };

      jest.spyOn(analyticsEngine, 'enrollFace').mockResolvedValue();

      const response = await testApp.request('/analytics/video/face-enrollment', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(enrollmentData)
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(analyticsEngine.enrollFace).toHaveBeenCalledWith(
        'tenant-123',
        enrollmentData.personId,
        enrollmentData.features,
        enrollmentData.metadata
      );
    });

    it('should validate enrollment data', async () => {
      const invalidData = { personId: 'person-123' }; // Missing features

      const response = await testApp.request('/analytics/video/face-enrollment', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(invalidData)
      });

      expect(response.status).toBe(400);
    });
  });

  describe('POST /analytics/video/watchlist', () => {
    it('should update face watchlist', async () => {
      const watchlistData = {
        type: 'face',
        items: ['person-1', 'person-2', 'person-3']
      };

      jest.spyOn(analyticsEngine, 'updateWatchlists').mockResolvedValue();

      const response = await testApp.request('/analytics/video/watchlist', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(watchlistData)
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(analyticsEngine.updateWatchlists).toHaveBeenCalledWith(
        'tenant-123',
        'face',
        watchlistData.items
      );
    });

    it('should validate watchlist type', async () => {
      const invalidData = {
        type: 'invalid',
        items: ['item1', 'item2']
      };

      const response = await testApp.request('/analytics/video/watchlist', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer valid-token',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(invalidData)
      });

      expect(response.status).toBe(400);
    });
  });

  describe('GET /analytics/predictions', () => {
    it('should generate incident predictions', async () => {
      const mockPredictions = [createMockIncidentPrediction()];
      
      jest.spyOn(analyticsEngine, 'generateIncidentPredictions').mockResolvedValue(mockPredictions);

      const response = await testApp.request('/analytics/predictions', {
        headers: { 'Authorization': 'Bearer valid-token' }
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveLength(1);
      expect(data.data[0]).toMatchObject(mockPredictions[0]);
    });
  });
});

// Export Test Utilities for other test files
export const testUtils = {
  createMockAccessEvent,
  createMockOccupancyData,
  createMockAnomalyScore,
  createMockPredictiveAlert,
  createMockFaceRecognitionEvent,
  createMockLicensePlateEvent,
  createMockBehaviorEvent,
  createMockVideoAnalyticsConfig,
  createMockCrowdAnalysis,
  createMockIncidentPrediction,
  mockPrisma,
  mockRedis,
  mockOpenSearch,
  mockWebSocket
};

}
